--- a/src/third_party/WebKit/WebCore/svg/animation/SMILTimeContainer.cpp
+++ b/src/third_party/WebKit/WebCore/svg/animation/SMILTimeContainer.cpp
@@ -255,7 +255,7 @@ void SMILTimeContainer::updateAnimations
     sortByPriority(toAnimate, elapsed);
     
     // Calculate animation contributions.
-    typedef HashMap<ElementAttributePair, SVGSMILElement*> ResultElementMap;
+    typedef HashMap<ElementAttributePair, RefPtr<SVGSMILElement> > ResultElementMap;
     ResultElementMap resultsElements;
     for (unsigned n = 0; n < toAnimate.size(); ++n) {
         SVGSMILElement* animation = toAnimate[n];
@@ -274,7 +274,7 @@ void SMILTimeContainer::updateAnimations
         
         // Results are accumulated to the first animation that animates a particular element/attribute pair.
         ElementAttributePair key(targetElement, attributeName); 
-        SVGSMILElement* resultElement = resultsElements.get(key);
+        SVGSMILElement* resultElement = resultsElements.get(key).get();
         if (!resultElement) {
             resultElement = animation;
             resultElement->resetToBaseValue(baseValueFor(key));
@@ -297,7 +297,7 @@ void SMILTimeContainer::updateAnimations
     Vector<SVGSMILElement*> animationsToApply;
     ResultElementMap::iterator end = resultsElements.end();
     for (ResultElementMap::iterator it = resultsElements.begin(); it != end; ++it)
-        animationsToApply.append(it->second);
+        animationsToApply.append(it->second.get());
 
     // Sort <animateTranform> to be the last one to be applied. <animate> may change transform attribute as
     // well (directly or indirectly by modifying <use> x/y) and this way transforms combine properly.
