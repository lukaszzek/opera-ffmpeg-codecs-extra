--- a/src/third_party/WebKit/WebCore/rendering/InlineFlowBox.cpp
+++ b/src/third_party/WebKit/WebCore/rendering/InlineFlowBox.cpp
@@ -650,13 +650,20 @@ void InlineFlowBox::paint(PaintInfo& pai
 
                 RenderBlock* cb = 0;
                 bool containingBlockPaintsContinuationOutline = inlineFlow->continuation() || inlineFlow->isInlineElementContinuation();
-                if (containingBlockPaintsContinuationOutline) {
-                    cb = renderer()->containingBlock()->containingBlock();
-
-                    for (RenderBoxModelObject* box = boxModelObject(); box != cb; box = box->parent()->enclosingBoxModelObject()) {
-                        if (box->hasSelfPaintingLayer()) {
-                            containingBlockPaintsContinuationOutline = false;
-                            break;
+                if (containingBlockPaintsContinuationOutline) {
+                    // FIXME: See https://bugs.webkit.org/show_bug.cgi?id=54690. We currently don't reconnect inline continuations
+                    // after a child removal. As a result, those merged inlines do not get seperated and hence not get enclosed by
+                    // anonymous blocks. In this case, it is better to bail out and paint it ourself.
+                    RenderBlock* enclosingAnonymousBlock = renderer()->containingBlock();
+                    if (!enclosingAnonymousBlock->isAnonymousBlock())
+                        containingBlockPaintsContinuationOutline = false;
+                    else {
+                        cb = enclosingAnonymousBlock->containingBlock();
+                        for (RenderBoxModelObject* box = boxModelObject(); box != cb; box = box->parent()->enclosingBoxModelObject()) {
+                            if (box->hasSelfPaintingLayer()) {
+                                containingBlockPaintsContinuationOutline = false;
+                                break;
+                            }
                         }
                     }
                 }
--- a/src/third_party/WebKit/WebCore/rendering/RenderBlock.cpp
+++ b/src/third_party/WebKit/WebCore/rendering/RenderBlock.cpp
@@ -2345,6 +2345,19 @@ void RenderBlock::addContinuationWithOut
     continuations->add(flow);
 }
 
+bool RenderBlock::paintsContinuationOutline(RenderInline* flow)
+{
+    ContinuationOutlineTableMap* table = continuationOutlineTable();
+    if (table->isEmpty())
+        return false;
+
+    ListHashSet<RenderInline*>* continuations = table->get(this);
+    if (!continuations)
+        return false;
+
+    return continuations->contains(flow);
+}
+
 void RenderBlock::paintContinuationOutlines(PaintInfo& info, int tx, int ty)
 {
     ContinuationOutlineTableMap* table = continuationOutlineTable();
--- a/src/third_party/WebKit/WebCore/rendering/RenderBlock.h
+++ b/src/third_party/WebKit/WebCore/rendering/RenderBlock.h
@@ -131,6 +131,7 @@ public:
     virtual void adjustForColumns(IntSize&, const IntPoint&) const;
 
     void addContinuationWithOutline(RenderInline*);
+    bool paintsContinuationOutline(RenderInline*);
 
     RenderBoxModelObject* continuation() const { return m_continuation; }
     void setContinuation(RenderBoxModelObject* c) { m_continuation = c; }
--- a/src/third_party/WebKit/WebCore/rendering/RenderInline.cpp
+++ b/src/third_party/WebKit/WebCore/rendering/RenderInline.cpp
@@ -54,6 +54,19 @@ RenderInline::RenderInline(Node* node)
 
 void RenderInline::destroy()
 {
+#ifndef NDEBUG
+    // Make sure we do not retain "this" in the continuation outline table map of our containing blocks.
+    if (parent() && style()->visibility() == VISIBLE && hasOutline()) {
+        bool containingBlockPaintsContinuationOutline = continuation() || isInlineElementContinuation();
+        if (containingBlockPaintsContinuationOutline) {
+            if (RenderBlock* cb = containingBlock()) {
+                if (RenderBlock* cbCb = cb->containingBlock())
+                    ASSERT(!cbCb->paintsContinuationOutline(this));
+            }
+        }
+    }
+#endif
+
     // Make sure to destroy anonymous children first while they are still connected to the rest of the tree, so that they will
     // properly dirty line boxes that they are removed from.  Effects that do :before/:after only on hover could crash otherwise.
     children()->destroyLeftoverChildren();
