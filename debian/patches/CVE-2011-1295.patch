--- a/src/third_party/WebKit/WebCore/dom/ContainerNode.cpp
+++ b/src/third_party/WebKit/WebCore/dom/ContainerNode.cpp
@@ -115,7 +115,7 @@ bool ContainerNode::insertBefore(PassRef
         Node* child = it->get();
 
         // If child is already present in the tree, first remove it from the old location.
-        if (Node* oldParent = child->parentNode())
+        if (ContainerNode* oldParent = child->parentNode())
             oldParent->removeChild(child, ec);
         if (ec)
             return false;
@@ -155,6 +155,8 @@ bool ContainerNode::insertBefore(PassRef
         child->setNextSibling(next.get());
         allowEventDispatch();
 
+	child->setDocumentRecursively(document());
+
         // Send notification about the children change.
         childrenChanged(false, refChildPreviousSibling.get(), next.get(), 1);
         notifyChildInserted(child);
@@ -225,7 +227,7 @@ bool ContainerNode::replaceChild(PassRef
         RefPtr<Node> nextChild = isFragment ? child->nextSibling() : 0;
 
         // Remove child from its old position.
-        if (Node* oldParent = child->parentNode())
+        if (ContainerNode* oldParent = child->parentNode())
             oldParent->removeChild(child.get(), ec);
         if (ec)
             return false;
@@ -242,6 +244,8 @@ bool ContainerNode::replaceChild(PassRef
         ASSERT(!child->nextSibling());
         ASSERT(!child->previousSibling());
 
+	child->setDocumentRecursively(document());
+
         // Add child after "prev".
         forbidEventDispatch();
         Node* next;
@@ -489,7 +493,7 @@ bool ContainerNode::appendChild(PassRefP
     for (NodeVector::const_iterator it = targets.begin(); it != targets.end(); ++it) {
         Node* child = it->get();
         // If child is already present in the tree, first remove it
-        if (Node* oldParent = child->parentNode()) {
+        if (ContainerNode* oldParent = child->parentNode()) {
             oldParent->removeChild(child, ec);
             if (ec)
                 return false;
--- a/src/third_party/WebKit/WebCore/dom/Document.cpp
+++ b/src/third_party/WebKit/WebCore/dom/Document.cpp
@@ -841,9 +841,8 @@ PassRefPtr<Node> Document::adoptNode(Pas
             if (source->parentNode())
                 source->parentNode()->removeChild(source.get(), ec);
     }
-                
-    for (Node* node = source.get(); node; node = node->traverseNextNode(source.get()))
-        node->setDocument(this);
+
+    source->setDocumentRecursively(this);
 
     return source;
 }
@@ -1071,7 +1070,7 @@ PassRefPtr<Range> Document::caretRangeFr
     Node* shadowAncestorNode = node->shadowAncestorNode();
     if (shadowAncestorNode != node) {
         unsigned offset = shadowAncestorNode->nodeIndex();
-        Node* container = shadowAncestorNode->parentNode();
+        ContainerNode* container = shadowAncestorNode->parentNode();
         return Range::create(this, container, offset, container, offset);
     }
 
--- a/src/third_party/WebKit/WebCore/dom/Node.cpp
+++ b/src/third_party/WebKit/WebCore/dom/Node.cpp
@@ -721,6 +721,21 @@ bool Node::hasNonEmptyBoundingBox() cons
     return false;
 }
 
+void Node::setDocumentRecursively(Document* document)
+{
+    // FIXME: To match Gecko, we should do this for nodes that are already in the document as well.
+    if (this->document() == document || this->inDocument())
+        return;
+
+    for (Node* node = this; node; node = node->traverseNextNode(this)) {
+        node->setDocument(document);
+        if (!node->isElementNode())
+            continue;
+        if (Node* shadow = toElement(node)->shadowRoot())
+            shadow->setDocumentRecursively(document);
+    }
+}
+
 inline void Node::setStyleChange(StyleChangeType changeType)
 {
     m_nodeFlags = (m_nodeFlags & ~StyleChangeMask) | changeType;
@@ -735,7 +750,7 @@ void Node::setNeedsStyleRecalc(StyleChan
         setStyleChange(changeType);
 
     if (styleChangeType() != NoStyleChange) {
-        for (Node* p = parentNode(); p && !p->childNeedsStyleRecalc(); p = p->parentNode())
+        for (ContainerNode* p = parentNode(); p && !p->childNeedsStyleRecalc(); p = p->parentNode())
             p->setChildNeedsStyleRecalc();
         if (document()->childNeedsStyleRecalc())
             document()->scheduleStyleRecalc();
@@ -975,7 +990,7 @@ void Node::removeCachedLabelsNodeList(Dy
     data->m_labelsNodeListCache = 0;
 }
 
-Node *Node::traverseNextNode(const Node *stayWithin) const
+Node* Node::traverseNextNode(const Node* stayWithin) const
 {
     if (firstChild())
         return firstChild();
@@ -991,7 +1006,7 @@ Node *Node::traverseNextNode(const Node
     return 0;
 }
 
-Node *Node::traverseNextSibling(const Node *stayWithin) const
+Node* Node::traverseNextSibling(const Node* stayWithin) const
 {
     if (this == stayWithin)
         return 0;
@@ -1015,7 +1030,7 @@ Node* Node::traverseNextNodePostOrder()
     return next;
 }
 
-Node *Node::traversePreviousNode(const Node *stayWithin) const
+Node* Node::traversePreviousNode(const Node* stayWithin) const
 {
     if (this == stayWithin)
         return 0;
@@ -1028,7 +1043,7 @@ Node *Node::traversePreviousNode(const N
     return parentNode();
 }
 
-Node *Node::traversePreviousNodePostOrder(const Node *stayWithin) const
+Node* Node::traversePreviousNodePostOrder(const Node* stayWithin) const
 {
     if (lastChild())
         return lastChild();
@@ -1081,21 +1096,27 @@ void Node::checkSetPrefix(const AtomicSt
     // Attribute-specific checks are in Attr::setPrefix().
 }
 
-bool Node::canReplaceChild(Node* newChild, Node*)
+static bool isChildTypeAllowed(Node* newParent, Node* child)
 {
-    if (newChild->nodeType() != DOCUMENT_FRAGMENT_NODE) {
-        if (!childTypeAllowed(newChild->nodeType()))
+    if (child->nodeType() != Node::DOCUMENT_FRAGMENT_NODE) {
+        if (!newParent->childTypeAllowed(child->nodeType()))
             return false;
-    } else {
-        for (Node *n = newChild->firstChild(); n; n = n->nextSibling()) {
-            if (!childTypeAllowed(n->nodeType())) 
-                return false;
-        }
     }
+
+    for (Node *n = child->firstChild(); n; n = n->nextSibling()) {
+        if (!newParent->childTypeAllowed(n->nodeType()))
+            return false;
+    }
+
     return true;
 }
 
-void Node::checkReplaceChild(Node* newChild, Node* oldChild, ExceptionCode& ec)
+bool Node::canReplaceChild(Node* newChild, Node*)
+{
+    return isChildTypeAllowed(this, newChild);
+}
+
+static void checkAcceptChild(Node* newParent, Node* newChild, ExceptionCode& ec)
 {
     // Perform error checking as required by spec for adding a new child. Used by replaceChild().
     
@@ -1106,121 +1127,56 @@ void Node::checkReplaceChild(Node* newCh
     }
     
     // NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly
-    if (isReadOnlyNode()) {
+    if (newParent->isReadOnlyNode()) {
         ec = NO_MODIFICATION_ALLOWED_ERR;
         return;
     }
     
-    bool shouldAdoptChild = false;
-    
     // WRONG_DOCUMENT_ERR: Raised if newChild was created from a different document than the one that
     // created this node.
     // We assume that if newChild is a DocumentFragment, all children are created from the same document
     // as the fragment itself (otherwise they could not have been added as children)
-    if (newChild->document() != document()) {
+    if (newChild->document() != newParent->document() && newChild->inDocument()) {
         // but if the child is not in a document yet then loosen the
         // restriction, so that e.g. creating an element with the Option()
         // constructor and then adding it to a different document works,
         // as it does in Mozilla and Mac IE.
-        if (!newChild->inDocument()) {
-            shouldAdoptChild = true;
-        } else {
-            ec = WRONG_DOCUMENT_ERR;
-            return;
-        }
+        ec = WRONG_DOCUMENT_ERR;
+        return;
     }
     
     // HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not allow children of the type of the
     // newChild node, or if the node to append is one of this node's ancestors.
     
     // check for ancestor/same node
-    if (newChild == this || isDescendantOf(newChild)) {
+    if (newChild == newParent || newParent->isDescendantOf(newChild)) {
         ec = HIERARCHY_REQUEST_ERR;
         return;
     }
-    
+}
+
+void Node::checkReplaceChild(Node* newChild, Node* oldChild, ExceptionCode& ec)
+{
+    checkAcceptChild(this, newChild, ec);
+    if (ec)
+        return;
     if (!canReplaceChild(newChild, oldChild)) {
         ec = HIERARCHY_REQUEST_ERR;
         return;
     }
-       
-    // change the document pointer of newChild and all of its children to be the new document
-    if (shouldAdoptChild)
-        for (Node* node = newChild; node; node = node->traverseNextNode(newChild))
-            node->setDocument(document());
 }
 
 void Node::checkAddChild(Node *newChild, ExceptionCode& ec)
 {
-    // Perform error checking as required by spec for adding a new child. Used by appendChild() and insertBefore().
-
-    // Not mentioned in spec: throw NOT_FOUND_ERR if newChild is null
-    if (!newChild) {
-        ec = NOT_FOUND_ERR;
+    checkAcceptChild(this, newChild, ec);
+    if (ec)
         return;
-    }
 
-    // NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly
-    if (isReadOnlyNode()) {
-        ec = NO_MODIFICATION_ALLOWED_ERR;
-        return;
-    }
-
-    bool shouldAdoptChild = false;
-
-    // WRONG_DOCUMENT_ERR: Raised if newChild was created from a different document than the one that
-    // created this node.
-    // We assume that if newChild is a DocumentFragment, all children are created from the same document
-    // as the fragment itself (otherwise they could not have been added as children)
-    if (newChild->document() != document()) {
-        // but if the child is not in a document yet then loosen the
-        // restriction, so that e.g. creating an element with the Option()
-        // constructor and then adding it to a different document works,
-        // as it does in Mozilla and Mac IE.
-        if (!newChild->inDocument()) {
-            shouldAdoptChild = true;
-        } else {
-            ec = WRONG_DOCUMENT_ERR;
-            return;
-        }
-    }
-
-    // HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not allow children of the type of the
-    // newChild node, or if the node to append is one of this node's ancestors.
-
-    // check for ancestor/same node
-    if (newChild == this || isDescendantOf(newChild)) {
+    if (!isChildTypeAllowed(this, newChild)) {
         ec = HIERARCHY_REQUEST_ERR;
         return;
     }
-    
-    if (newChild->nodeType() != DOCUMENT_FRAGMENT_NODE) {
-        if (!childTypeAllowed(newChild->nodeType())) {
-            ec = HIERARCHY_REQUEST_ERR;
-            return;
-        }
-    }
-    else {
-        for (Node *n = newChild->firstChild(); n; n = n->nextSibling()) {
-            if (!childTypeAllowed(n->nodeType())) {
-                ec = HIERARCHY_REQUEST_ERR;
-                return;
-            }
-        }
-    }
-
-    // If an element is moved from a document and then eventually back again the collection cache for
-    // that element may contain stale data as changes made to it will have updated the DOMTreeVersion
-    // of the document it was moved to. By increasing the DOMTreeVersion of the donating document here
-    // we ensure that the collection cache will be invalidated as needed when the element is moved back.
-    if (this->document())
-        this->document()->incDOMTreeVersion();
 
-    
-    // change the document pointer of newChild and all of its children to be the new document
-    if (shouldAdoptChild)
-        for (Node* node = newChild; node; node = node->traverseNextNode(newChild))
-            node->setDocument(document());
 }
 
 bool Node::isDescendantOf(const Node *other) const
@@ -1228,7 +1184,7 @@ bool Node::isDescendantOf(const Node *ot
     // Return true if other is an ancestor of this, otherwise false
     if (!other)
         return false;
-    for (const Node *n = parentNode(); n; n = n->parentNode()) {
+    for (const ContainerNode* n = parentNode(); n; n = n->parentNode()) {
         if (n == other)
             return true;
     }
@@ -1399,7 +1355,7 @@ void Node::createRendererIfNeeded()
 
     ASSERT(!renderer());
     
-    Node* parent = parentNode();    
+    ContainerNode* parent = parentNode();    
     ASSERT(parent);
     
     RenderObject* parentRenderer = parent->renderer();
@@ -2037,7 +1993,7 @@ String Node::textContent(bool convertBRs
     return content.toString();
 }
 
-void Node::setTextContent(const String &text, ExceptionCode& ec)
+void Node::setTextContent(const String& text, ExceptionCode& ec)
 {           
     switch (nodeType()) {
         case TEXT_NODE:
@@ -2045,33 +2001,32 @@ void Node::setTextContent(const String &
         case COMMENT_NODE:
         case PROCESSING_INSTRUCTION_NODE:
             setNodeValue(text, ec);
-            break;
+            return;
         case ELEMENT_NODE:
         case ATTRIBUTE_NODE:
         case ENTITY_NODE:
         case ENTITY_REFERENCE_NODE:
         case DOCUMENT_FRAGMENT_NODE: {
-            ContainerNode *container = static_cast<ContainerNode *>(this);
-            
+            ContainerNode* container = toContainerNode(this);
             container->removeChildren();
-            
             if (!text.isEmpty())
-                appendChild(document()->createTextNode(text), ec);
-            break;
+                container->appendChild(document()->createTextNode(text), ec);
+            return;
         }
         case DOCUMENT_NODE:
         case DOCUMENT_TYPE_NODE:
         case NOTATION_NODE:
-        default:
-            // Do nothing
-            break;
+        case XPATH_NAMESPACE_NODE:
+            // Do nothing.
+            return;
     }
+    ASSERT_NOT_REACHED();
 }
 
 Element* Node::ancestorElement() const
 {
     // In theory, there can be EntityReference nodes between elements, but this is currently not supported.
-    for (Node* n = parentNode(); n; n = n->parentNode()) {
+    for (ContainerNode* n = parentNode(); n; n = n->parentNode()) {
         if (n->isElementNode())
             return static_cast<Element*>(n);
     }
--- a/src/third_party/WebKit/WebCore/dom/Node.h
+++ b/src/third_party/WebKit/WebCore/dom/Node.h
@@ -363,6 +363,9 @@ public:
     // removed from its previous document.
     void setDocument(Document*);
 
+    // Used by the basic DOM methods (e.g., appendChild()).
+    void setDocumentRecursively(Document*);
+
     // Returns true if this node is associated with a document and is in its associated document's
     // node tree, false otherwise.
     bool inDocument() const 
@@ -388,7 +391,7 @@ public:
      * see @ref traversePreviousNode()
      */
     Node* traverseNextNode(const Node* stayWithin = 0) const;
-    
+
     // Like traverseNextNode, but skips children and starts with the next sibling.
     Node* traverseNextSibling(const Node* stayWithin = 0) const;
 
--- a/src/third_party/WebKit/WebCore/css/CSSStyleSelector.cpp
+++ b/src/third_party/WebKit/WebCore/css/CSSStyleSelector.cpp
@@ -1943,7 +1943,7 @@ CSSStyleSelector::SelectorMatch CSSStyle
     switch (relation) {
         case CSSSelector::Descendant:
             while (true) {
-                Node* n = e->parentNode();
+                ContainerNode* n = e->parentNode();
                 if (!n || !n->isElementNode())
                     return SelectorFailsCompletely;
                 e = static_cast<Element*>(n);
@@ -1954,7 +1954,7 @@ CSSStyleSelector::SelectorMatch CSSStyle
             break;
         case CSSSelector::Child:
         {
-            Node* n = e->parentNode();
+            ContainerNode* n = e->parentNode();
             if (!n || !n->isElementNode())
                 return SelectorFailsCompletely;
             e = static_cast<Element*>(n);
--- a/src/third_party/WebKit/WebCore/dom/ContainerNode.h
+++ b/src/third_party/WebKit/WebCore/dom/ContainerNode.h
@@ -107,6 +107,21 @@ private:
     Node* m_lastChild;
 };
 
+inline ContainerNode* toContainerNode(Node* node)
+{
+    ASSERT(!node || node->isContainerNode());
+    return static_cast<ContainerNode*>(node);
+}
+
+inline const ContainerNode* toContainerNode(const Node* node)
+{
+    ASSERT(!node || node->isContainerNode());
+    return static_cast<const ContainerNode*>(node);
+}
+
+// This will catch anyone doing an unnecessary cast.
+void toContainerNode(const ContainerNode*);
+
 inline ContainerNode::ContainerNode(Document* document, ConstructionType type)
     : Node(document, type)
     , m_firstChild(0)
@@ -116,26 +131,22 @@ inline ContainerNode::ContainerNode(Docu
 
 inline unsigned Node::containerChildNodeCount() const
 {
-    ASSERT(isContainerNode());
-    return static_cast<const ContainerNode*>(this)->childNodeCount();
+    return toContainerNode(this)->childNodeCount();
 }
 
 inline Node* Node::containerChildNode(unsigned index) const
 {
-    ASSERT(isContainerNode());
-    return static_cast<const ContainerNode*>(this)->childNode(index);
+    return toContainerNode(this)->childNode(index);
 }
 
 inline Node* Node::containerFirstChild() const
 {
-    ASSERT(isContainerNode());
-    return static_cast<const ContainerNode*>(this)->firstChild();
+    return toContainerNode(this)->firstChild();
 }
 
 inline Node* Node::containerLastChild() const
 {
-    ASSERT(isContainerNode());
-    return static_cast<const ContainerNode*>(this)->lastChild();
+    return toContainerNode(this)->lastChild();
 }
 
 } // namespace WebCore
--- a/src/third_party/WebKit/WebCore/dom/DynamicNodeList.cpp
+++ b/src/third_party/WebKit/WebCore/dom/DynamicNodeList.cpp
@@ -124,7 +124,7 @@ Node* DynamicNodeList::itemWithName(cons
     if (m_rootNode->isDocumentNode() || m_rootNode->inDocument()) {
         Element* node = m_rootNode->document()->getElementById(elementId);
         if (node && nodeMatches(node)) {
-            for (Node* p = node->parentNode(); p; p = p->parentNode()) {
+            for (ContainerNode* p = node->parentNode(); p; p = p->parentNode()) {
                 if (p == m_rootNode)
                     return node;
             }
--- a/src/third_party/WebKit/WebCore/dom/Element.cpp
+++ b/src/third_party/WebKit/WebCore/dom/Element.cpp
@@ -113,18 +113,19 @@ PassRefPtr<DocumentFragment> Element::cr
     for (RefPtr<Node> node = fragment->firstChild(); node; node = nextNode) {
         nextNode = node->nextSibling();
         if (node->hasTagName(htmlTag) || node->hasTagName(bodyTag)) {
-            Node* firstChild = node->firstChild();
+            HTMLElement* element = static_cast<HTMLElement*>(node.get());
+            Node* firstChild = element->firstChild();
             if (firstChild)
                 nextNode = firstChild;
             RefPtr<Node> nextChild;
             for (RefPtr<Node> child = firstChild; child; child = nextChild) {
                 nextChild = child->nextSibling();
-                node->removeChild(child.get(), ignoredExceptionCode);
+                element->removeChild(child.get(), ignoredExceptionCode);
                 ASSERT(!ignoredExceptionCode);
-                fragment->insertBefore(child, node.get(), ignoredExceptionCode);
+                fragment->insertBefore(child, element, ignoredExceptionCode);
                 ASSERT(!ignoredExceptionCode);
             }
-            fragment->removeChild(node.get(), ignoredExceptionCode);
+            fragment->removeChild(element, ignoredExceptionCode);
             ASSERT(!ignoredExceptionCode);
         } else if (node->hasTagName(headTag)) {
             fragment->removeChild(node.get(), ignoredExceptionCode);
@@ -746,7 +747,7 @@ KURL Element::baseURI() const
     if (!base.protocol().isEmpty())
         return base;
 
-    Node* parent = parentNode();
+    ContainerNode* parent = parentNode();
     if (!parent)
         return base;
 
--- a/src/third_party/WebKit/WebCore/dom/Element.h
+++ b/src/third_party/WebKit/WebCore/dom/Element.h
@@ -353,25 +353,40 @@ private:
     mutable RefPtr<NamedNodeMap> m_attributeMap;
 };
     
+inline Element* toElement(Node* node)
+{
+    ASSERT(!node || node->isElementNode());
+    return static_cast<Element*>(node);
+}
+
+inline const Element* toElement(const Node* node)
+{
+    ASSERT(!node || node->isElementNode());
+    return static_cast<const Element*>(node);
+}
+
+// This will catch anyone doing an unnecessary cast.
+void toElement(const Element*);
+
 inline bool Node::hasTagName(const QualifiedName& name) const
 {
-    return isElementNode() && static_cast<const Element*>(this)->hasTagName(name);
+    return isElementNode() && toElement(this)->hasTagName(name);
 }
 
 inline bool Node::hasAttributes() const
 {
-    return isElementNode() && static_cast<const Element*>(this)->hasAttributes();
+    return isElementNode() && toElement(this)->hasAttributes();
 }
 
 inline NamedNodeMap* Node::attributes() const
 {
-    return isElementNode() ? static_cast<const Element*>(this)->attributes() : 0;
+    return isElementNode() ? toElement(this)->attributes() : 0;
 }
 
 inline Element* Node::parentElement() const
 {
-    Node* parent = parentNode();
-    return parent && parent->isElementNode() ? static_cast<Element*>(parent) : 0;
+    ContainerNode* parent = parentNode();
+    return parent && parent->isElementNode() ? toElement(parent) : 0;
 }
 
 inline NamedNodeMap* Element::attributes(bool readonly) const
--- a/src/third_party/WebKit/WebCore/dom/Position.cpp
+++ b/src/third_party/WebKit/WebCore/dom/Position.cpp
@@ -239,7 +239,7 @@ Position Position::previous(PositionMove
         }
     }
 
-    Node* parent = n->parentNode();
+    ContainerNode* parent = n->parentNode();
     if (!parent)
         return *this;
 
@@ -271,7 +271,7 @@ Position Position::next(PositionMoveType
         return Position(n, (moveType == Character) ? uncheckedNextOffset(n, o) : o + 1);
     }
 
-    Node* parent = n->parentNode();
+    ContainerNode* parent = n->parentNode();
     if (!parent)
         return *this;
 
--- a/src/third_party/WebKit/WebCore/dom/Range.cpp
+++ b/src/third_party/WebKit/WebCore/dom/Range.cpp
@@ -363,7 +363,7 @@ Range::CompareResults Range::compareNode
         return NODE_BEFORE;
     }
 
-    Node* parentNode = refNode->parentNode();
+    ContainerNode* parentNode = refNode->parentNode();
     int nodeIndex = refNode->nodeIndex();
     
     if (!parentNode) {
@@ -562,7 +562,7 @@ bool Range::intersectsNode(Node* refNode
         return false;
     }
 
-    Node* parentNode = refNode->parentNode();
+    ContainerNode* parentNode = refNode->parentNode();
     int nodeIndex = refNode->nodeIndex();
     
     if (!parentNode) {
@@ -657,7 +657,7 @@ PassRefPtr<DocumentFragment> Range::proc
                 else if (action == CLONE_CONTENTS)
                     fragment->appendChild(n->cloneNode(true), ec);
                 else
-                    m_start.container()->removeChild(n, ec);
+                    toContainerNode(m_start.container())->removeChild(n, ec);
                 n = next;
                 i++;
             }
@@ -720,12 +720,12 @@ PassRefPtr<DocumentFragment> Range::proc
                 else if (action == CLONE_CONTENTS)
                     leftContents->appendChild(n->cloneNode(true), ec);
                 else
-                    m_start.container()->removeChild(n, ec);
+                    toContainerNode(m_start.container())->removeChild(n, ec);
                 n = next;
             }
         }
 
-        Node* leftParent = m_start.container()->parentNode();
+        ContainerNode* leftParent = m_start.container()->parentNode();
         Node* n = m_start.container()->nextSibling();
         for (; leftParent != commonRoot; leftParent = leftParent->parentNode()) {
             if (action == EXTRACT_CONTENTS || action == CLONE_CONTENTS) {
@@ -790,12 +790,12 @@ PassRefPtr<DocumentFragment> Range::proc
                     else if (action == CLONE_CONTENTS)
                         rightContents->insertBefore(n->cloneNode(true), rightContents->firstChild(), ec);
                     else
-                        m_end.container()->removeChild(n, ec);
+                        toContainerNode(m_end.container())->removeChild(n, ec);
                 }
             }
         }
 
-        Node* rightParent = m_end.container()->parentNode();
+        ContainerNode* rightParent = m_end.container()->parentNode();
         Node* n = m_end.container()->previousSibling();
         for (; rightParent != commonRoot; rightParent = rightParent->parentNode()) {
             if (action == EXTRACT_CONTENTS || action == CLONE_CONTENTS) {
@@ -1148,7 +1148,7 @@ void Range::checkNodeBA(Node* n, Excepti
     }
 
     Node* root = n;
-    while (Node* parent = root->parentNode())
+    while (ContainerNode* parent = root->parentNode())
         root = parent;
 
     switch (root->nodeType()) {
@@ -1274,7 +1274,7 @@ void Range::selectNode(Node* refNode, Ex
     // INVALID_NODE_TYPE_ERR: Raised if an ancestor of refNode is an Entity, Notation or
     // DocumentType node or if refNode is a Document, DocumentFragment, Attr, Entity, or Notation
     // node.
-    for (Node* anc = refNode->parentNode(); anc; anc = anc->parentNode()) {
+    for (ContainerNode* anc = refNode->parentNode(); anc; anc = anc->parentNode()) {
         switch (anc->nodeType()) {
             case Node::ATTRIBUTE_NODE:
             case Node::CDATA_SECTION_NODE:
@@ -1444,7 +1444,7 @@ void Range::surroundContents(PassRefPtr<
 
     ec = 0;
     while (Node* n = newParent->firstChild()) {
-        newParent->removeChild(n, ec);
+        toContainerNode(newParent.get())->removeChild(n, ec);
         if (ec)
             return;
     }
--- a/src/third_party/WebKit/WebCore/dom/Text.cpp
+++ b/src/third_party/WebKit/WebCore/dom/Text.cpp
@@ -151,7 +151,7 @@ PassRefPtr<Text> Text::replaceWholeText(
     RefPtr<Text> endText = const_cast<Text*>(latestLogicallyAdjacentTextNode(this));
 
     RefPtr<Text> protectedThis(this); // Mutation event handlers could cause our last ref to go away
-    Node* parent = parentNode(); // Protect against mutation handlers moving this node during traversal
+    ContainerNode* parent = parentNode(); // Protect against mutation handlers moving this node during traversal
     ExceptionCode ignored = 0;
     for (RefPtr<Node> n = startText; n && n != this && n->isTextNode() && n->parentNode() == parent;) {
         RefPtr<Node> nodeToRemove(n.release());
--- a/src/third_party/WebKit/WebCore/dom/TreeWalker.cpp
+++ b/src/third_party/WebKit/WebCore/dom/TreeWalker.cpp
@@ -94,7 +94,7 @@ Node* TreeWalker::firstChild(ScriptState
                 node = node->nextSibling();
                 break;
             }
-            Node* parent = node->parentNode();
+            ContainerNode* parent = node->parentNode();
             if (!parent || parent == root() || parent == m_current)
                 return 0;
             node = parent;
@@ -127,7 +127,7 @@ Node* TreeWalker::lastChild(ScriptState*
                 node = node->previousSibling();
                 break;
             }
-            Node* parent = node->parentNode();
+            ContainerNode* parent = node->parentNode();
             if (!parent || parent == root() || parent == m_current)
                 return 0;
             node = parent;
@@ -234,7 +234,7 @@ Node* TreeWalker::previousNode(ScriptSta
         }
         if (node == root())
             return 0;
-        Node* parent = node->parentNode();
+        ContainerNode* parent = node->parentNode();
         if (!parent)
             return 0;
         node = parent;
--- a/src/third_party/WebKit/WebCore/dom/XMLDocumentParser.cpp
+++ b/src/third_party/WebKit/WebCore/dom/XMLDocumentParser.cpp
@@ -289,47 +289,47 @@ void XMLDocumentParser::insertErrorMessa
 
     // Create elements for display
     ExceptionCode ec = 0;
-    Document* doc = document();
-    Node* documentElement = doc->documentElement();
+    Document* document = this->document();
+    Element* documentElement = document->documentElement();
     if (!documentElement) {
-        RefPtr<Node> rootElement = doc->createElement(htmlTag, false);
-        doc->appendChild(rootElement, ec);
-        RefPtr<Node> body = doc->createElement(bodyTag, false);
+        RefPtr<Element> rootElement = document->createElement(htmlTag, false);
+        document->appendChild(rootElement, ec);
+        RefPtr<Element> body = document->createElement(bodyTag, false);
         rootElement->appendChild(body, ec);
         documentElement = body.get();
     }
 #if ENABLE(SVG)
     else if (documentElement->namespaceURI() == SVGNames::svgNamespaceURI) {
-        RefPtr<Node> rootElement = doc->createElement(htmlTag, false);
-        RefPtr<Node> body = doc->createElement(bodyTag, false);
+        RefPtr<Element> rootElement = document->createElement(htmlTag, false);
+        RefPtr<Element> body = document->createElement(bodyTag, false);
         rootElement->appendChild(body, ec);
         body->appendChild(documentElement, ec);
-        doc->appendChild(rootElement.get(), ec);
+        document->appendChild(rootElement.get(), ec);
         documentElement = body.get();
     }
 #endif
 #if ENABLE(WML)
     else if (isWMLDocument()) {
-        RefPtr<Node> rootElement = doc->createElement(htmlTag, false);
-        RefPtr<Node> body = doc->createElement(bodyTag, false);
+        RefPtr<Element> rootElement = document->createElement(htmlTag, false);
+        RefPtr<Element> body = document->createElement(bodyTag, false);
         rootElement->appendChild(body, ec);
         body->appendChild(documentElement, ec);
-        doc->appendChild(rootElement.get(), ec);
+        document->appendChild(rootElement.get(), ec);
         documentElement = body.get();
     }
 #endif
 
-    RefPtr<Element> reportElement = createXHTMLParserErrorHeader(doc, m_errorMessages);
+    RefPtr<Element> reportElement = createXHTMLParserErrorHeader(document, m_errorMessages);
     documentElement->insertBefore(reportElement, documentElement->firstChild(), ec);
 #if ENABLE(XSLT)
-    if (doc->transformSourceDocument()) {
-        RefPtr<Element> par = doc->createElement(pTag, false);
-        reportElement->appendChild(par, ec);
-        par->setAttribute(styleAttr, "white-space: normal");
-        par->appendChild(doc->createTextNode("This document was created as the result of an XSL transformation. The line and column numbers given are from the transformed result."), ec);
+    if (document->transformSourceDocument()) {
+        RefPtr<Element> paragraph = document->createElement(pTag, false);
+        paragraph->setAttribute(styleAttr, "white-space: normal");
+        paragraph->appendChild(document->createTextNode("This document was created as the result of an XSL transformation. The line and column numbers given are from the transformed result."), ec);
+        reportElement->appendChild(paragraph.release(), ec);
     }
 #endif
-    doc->updateStyleIfNeeded();
+    document->updateStyleIfNeeded();
 }
 
 void XMLDocumentParser::notifyFinished(CachedResource* unusedResource)
--- a/src/third_party/WebKit/WebCore/dom/XMLDocumentParserLibxml2.cpp
+++ b/src/third_party/WebKit/WebCore/dom/XMLDocumentParserLibxml2.cpp
@@ -581,7 +581,7 @@ XMLDocumentParser::XMLDocumentParser(Doc
     while (parentElement) {
         elemStack.append(parentElement);
 
-        Node* n = parentElement->parentNode();
+        ContainerNode* n = parentElement->parentNode();
         if (!n || !n->isElementNode())
             break;
         parentElement = static_cast<Element*>(n);
--- a/src/third_party/WebKit/WebCore/editing/ApplyStyleCommand.cpp
+++ b/src/third_party/WebKit/WebCore/editing/ApplyStyleCommand.cpp
@@ -1191,7 +1191,7 @@ void ApplyStyleCommand::replaceWithSpanO
     if (removeNode)
         removeNodePreservingChildren(elem);
     else {
-        HTMLElement* newSpanElement = replaceNodeWithSpanPreservingChildrenAndAttributes(elem);
+        HTMLElement* newSpanElement = replaceElementWithSpanPreservingChildrenAndAttributes(elem);
         ASSERT(newSpanElement && newSpanElement->inDocument());
         elem = newSpanElement;
     }
--- a/src/third_party/WebKit/WebCore/editing/BreakBlockquoteCommand.cpp
+++ b/src/third_party/WebKit/WebCore/editing/BreakBlockquoteCommand.cpp
@@ -67,7 +67,7 @@ void BreakBlockquoteCommand::doApply()
     
     // Find the top-most blockquote from the start.
     Element* topBlockquote = 0;
-    for (Node *node = pos.node()->parentNode(); node; node = node->parentNode()) {
+    for (ContainerNode* node = pos.node()->parentNode(); node; node = node->parentNode()) {
         if (isMailBlockquote(node))
             topBlockquote = static_cast<Element*>(node);
     }
--- a/src/third_party/WebKit/WebCore/editing/CompositeEditCommand.cpp
+++ b/src/third_party/WebKit/WebCore/editing/CompositeEditCommand.cpp
@@ -211,12 +211,12 @@ void CompositeEditCommand::removeNodePre
 
 void CompositeEditCommand::removeNodeAndPruneAncestors(PassRefPtr<Node> node)
 {
-    RefPtr<Node> parent = node->parentNode();
+    RefPtr<ContainerNode> parent = node->parentNode();
     removeNode(node);
     prune(parent.release());
 }
 
-HTMLElement* CompositeEditCommand::replaceNodeWithSpanPreservingChildrenAndAttributes(PassRefPtr<Node> node)
+HTMLElement* CompositeEditCommand::replaceElementWithSpanPreservingChildrenAndAttributes(PassRefPtr<HTMLElement> node)
 {
     // It would also be possible to implement all of ReplaceNodeWithSpanCommand
     // as a series of existing smaller edit commands.  Someone who wanted to
@@ -249,7 +249,7 @@ void CompositeEditCommand::prune(PassRef
         if (renderer && (!renderer->canHaveChildren() || hasARenderedDescendant(node.get()) || node->rootEditableElement() == node))
             return;
             
-        RefPtr<Node> next = node->parentNode();
+        RefPtr<ContainerNode> next = node->parentNode();
         removeNode(node);
         node = next;
     }
@@ -1005,7 +1005,7 @@ bool CompositeEditCommand::breakOutOfEmp
 
     RefPtr<CSSMutableStyleDeclaration> style = ApplyStyleCommand::editingStyleAtPosition(endingSelection().start(), IncludeTypingStyle);
 
-    Node* listNode = emptyListItem->parentNode();
+    ContainerNode* listNode = emptyListItem->parentNode();
     // FIXME: Can't we do something better when the immediate parent wasn't a list node?
     if (!listNode
         || (!listNode->hasTagName(ulTag) && !listNode->hasTagName(olTag))
@@ -1013,7 +1013,7 @@ bool CompositeEditCommand::breakOutOfEmp
         return false;
 
     RefPtr<Element> newBlock = 0;
-    if (Node* blockEnclosingList = listNode->parentNode()) {
+    if (ContainerNode* blockEnclosingList = listNode->parentNode()) {
         if (blockEnclosingList->hasTagName(liTag)) { // listNode is inside another list item
             if (visiblePositionAfterNode(blockEnclosingList) == visiblePositionAfterNode(listNode)) {
                 // If listNode appears at the end of the outer list item, then move listNode outside of this list item
@@ -1104,7 +1104,7 @@ bool CompositeEditCommand::breakOutOfEmp
     } else {
         ASSERT(caretPos.deprecatedEditingOffset() == 0);
         Text* textNode = static_cast<Text*>(caretPos.node());
-        Node* parentNode = textNode->parentNode();
+        ContainerNode* parentNode = textNode->parentNode();
         // The preserved newline must be the first thing in the node, since otherwise the previous
         // paragraph would be quoted, and we verified that it wasn't above.
         deleteTextFromNode(textNode, 0, 1);
--- a/src/third_party/WebKit/WebCore/editing/CompositeEditCommand.h
+++ b/src/third_party/WebKit/WebCore/editing/CompositeEditCommand.h
@@ -72,7 +72,7 @@ protected:
     void removeNodeAttribute(PassRefPtr<Element>, const QualifiedName& attribute);
     void removeChildrenInRange(PassRefPtr<Node>, unsigned from, unsigned to);
     virtual void removeNode(PassRefPtr<Node>);
-    HTMLElement* replaceNodeWithSpanPreservingChildrenAndAttributes(PassRefPtr<Node>);
+    HTMLElement* replaceElementWithSpanPreservingChildrenAndAttributes(PassRefPtr<HTMLElement>);
     void removeNodePreservingChildren(PassRefPtr<Node>);
     void removeNodeAndPruneAncestors(PassRefPtr<Node>);
     void prune(PassRefPtr<Node>);
--- a/src/third_party/WebKit/WebCore/editing/DeleteButtonController.cpp
+++ b/src/third_party/WebKit/WebCore/editing/DeleteButtonController.cpp
@@ -121,7 +121,7 @@ static bool isDeletableElement(const Nod
             return true;
 
         // Allow blocks that have a different background from it's parent
-        Node* parentNode = node->parentNode();
+        ContainerNode* parentNode = node->parentNode();
         if (!parentNode)
             return false;
 
--- a/src/third_party/WebKit/WebCore/editing/IndentOutdentCommand.cpp
+++ b/src/third_party/WebKit/WebCore/editing/IndentOutdentCommand.cpp
@@ -263,7 +263,7 @@ void IndentOutdentCommand::outdentParagr
         // outdentRegion() assumes it is operating on the first paragraph of an enclosing blockquote, but if there are multiply nested blockquotes and we've
         // just removed one, then this assumption isn't true. By splitting the next containing blockquote after this node, we keep this assumption true
         if (splitPoint) {
-            if (Node* splitPointParent = splitPoint->parentNode()) {
+            if (ContainerNode* splitPointParent = splitPoint->parentNode()) {
                 if (splitPointParent->hasTagName(blockquoteTag)
                     && !splitPoint->hasTagName(blockquoteTag)
                     && splitPointParent->parentNode()->isContentEditable()) // We can't outdent if there is no place to go!
--- a/src/third_party/WebKit/WebCore/editing/InsertNodeBeforeCommand.cpp
+++ b/src/third_party/WebKit/WebCore/editing/InsertNodeBeforeCommand.cpp
@@ -45,7 +45,7 @@ InsertNodeBeforeCommand::InsertNodeBefor
 
 void InsertNodeBeforeCommand::doApply()
 {
-    Node* parent = m_refChild->parentNode();
+    ContainerNode* parent = m_refChild->parentNode();
     if (!parent || !parent->isContentEditable())
         return;
 
--- a/src/third_party/WebKit/WebCore/editing/JoinTextNodesCommand.cpp
+++ b/src/third_party/WebKit/WebCore/editing/JoinTextNodesCommand.cpp
@@ -45,7 +45,7 @@ void JoinTextNodesCommand::doApply()
     if (m_text1->nextSibling() != m_text2)
         return;
 
-    Node* parent = m_text2->parentNode();
+    ContainerNode* parent = m_text2->parentNode();
     if (!parent || !parent->isContentEditable())
         return;
     
@@ -62,7 +62,7 @@ void JoinTextNodesCommand::doUnapply()
     if (m_text1->parentNode())
         return;
 
-    Node* parent = m_text2->parentNode();
+    ContainerNode* parent = m_text2->parentNode();
     if (!parent || !parent->isContentEditable())
         return;
 
--- a/src/third_party/WebKit/WebCore/editing/MergeIdenticalElementsCommand.cpp
+++ b/src/third_party/WebKit/WebCore/editing/MergeIdenticalElementsCommand.cpp
@@ -67,7 +67,7 @@ void MergeIdenticalElementsCommand::doUn
 
     RefPtr<Node> atChild = m_atChild.release();
 
-    Node* parent = m_element2->parent();
+    ContainerNode* parent = m_element2->parent();
     if (!parent || !parent->isContentEditable())
         return;
 
--- a/src/third_party/WebKit/WebCore/editing/RemoveNodeCommand.cpp
+++ b/src/third_party/WebKit/WebCore/editing/RemoveNodeCommand.cpp
@@ -41,7 +41,7 @@ RemoveNodeCommand::RemoveNodeCommand(Pas
 
 void RemoveNodeCommand::doApply()
 {
-    Node* parent = m_node->parentNode();
+    ContainerNode* parent = m_node->parentNode();
     if (!parent || !parent->isContentEditable())
         return;
 
@@ -54,7 +54,7 @@ void RemoveNodeCommand::doApply()
 
 void RemoveNodeCommand::doUnapply()
 {
-    RefPtr<Node> parent = m_parent.release();
+    RefPtr<ContainerNode> parent = m_parent.release();
     RefPtr<Node> refChild = m_refChild.release();
     if (!parent || !parent->isContentEditable())
         return;
--- a/src/third_party/WebKit/WebCore/editing/RemoveNodeCommand.h
+++ b/src/third_party/WebKit/WebCore/editing/RemoveNodeCommand.h
@@ -44,7 +44,7 @@ private:
     virtual void doUnapply();
 
     RefPtr<Node> m_node;
-    RefPtr<Node> m_parent;
+    RefPtr<ContainerNode> m_parent;
     RefPtr<Node> m_refChild;    
 };
 
--- a/src/third_party/WebKit/WebCore/editing/ReplaceNodeWithSpanCommand.cpp
+++ b/src/third_party/WebKit/WebCore/editing/ReplaceNodeWithSpanCommand.cpp
@@ -71,18 +71,18 @@ static void swapInNodePreservingAttribut
 
 void ReplaceNodeWithSpanCommand::doApply()
 {
-    if (!m_node->inDocument())
+    if (!m_elementToReplace->inDocument())
         return;
     if (!m_spanElement)
-        m_spanElement = createHTMLElement(m_node->document(), spanTag);
-    swapInNodePreservingAttributesAndChildren(m_spanElement.get(), m_node.get());
+        m_spanElement = createHTMLElement(m_elementToReplace->document(), spanTag);
+    swapInNodePreservingAttributesAndChildren(m_spanElement.get(), m_elementToReplace.get());
 }
 
 void ReplaceNodeWithSpanCommand::doUnapply()
 {
     if (!m_spanElement->inDocument())
         return;
-    swapInNodePreservingAttributesAndChildren(m_node.get(), m_spanElement.get());
+    swapInNodePreservingAttributesAndChildren(m_elementToReplace.get(), m_spanElement.get());
 }
 
 } // namespace WebCore
--- a/src/third_party/WebKit/WebCore/editing/ReplaceNodeWithSpanCommand.h
+++ b/src/third_party/WebKit/WebCore/editing/ReplaceNodeWithSpanCommand.h
@@ -48,12 +48,12 @@ public:
     HTMLElement* spanElement() { return m_spanElement.get(); }
 
 private:
-    ReplaceNodeWithSpanCommand(PassRefPtr<Node>);
+    ReplaceNodeWithSpanCommand(PassRefPtr<HTMLElement>);
 
     virtual void doApply();
     virtual void doUnapply();
 
-    RefPtr<Node> m_node;
+    RefPtr<HTMLElement> m_elementToReplace;
     RefPtr<HTMLElement> m_spanElement;
 };
 
--- a/src/third_party/WebKit/WebCore/editing/ReplaceSelectionCommand.cpp
+++ b/src/third_party/WebKit/WebCore/editing/ReplaceSelectionCommand.cpp
@@ -76,9 +76,9 @@ public:
     void removeNodePreservingChildren(Node*);
 
 private:
-    PassRefPtr<Node> insertFragmentForTestRendering(Node* context);
+    PassRefPtr<StyledElement> insertFragmentForTestRendering(Node* context);
     void removeUnrenderedNodes(Node*);
-    void restoreTestRenderingNodesToFragment(Node*);
+    void restoreTestRenderingNodesToFragment(StyledElement*);
     void removeInterchangeNodes(Node*);
     
     void insertNodeBefore(PassRefPtr<Node> node, Node* refNode);
@@ -150,7 +150,7 @@ ReplacementFragment::ReplacementFragment
     }
 
     Node* styleNode = selection.base().node();
-    RefPtr<Node> holder = insertFragmentForTestRendering(styleNode);
+    RefPtr<StyledElement> holder = insertFragmentForTestRendering(styleNode);
     
     RefPtr<Range> range = VisibleSelection::selectionFromContentsOfNode(holder.get()).toNormalizedRange();
     String text = plainText(range.get());
@@ -208,7 +208,7 @@ void ReplacementFragment::removeNode(Pas
     if (!node)
         return;
     
-    Node *parent = node->parentNode();
+    ContainerNode* parent = node->parentNode();
     if (!parent)
         return;
     
@@ -222,7 +222,7 @@ void ReplacementFragment::insertNodeBefo
     if (!node || !refNode)
         return;
         
-    Node* parent = refNode->parentNode();
+    ContainerNode* parent = refNode->parentNode();
     if (!parent)
         return;
         
@@ -231,9 +231,9 @@ void ReplacementFragment::insertNodeBefo
     ASSERT(ec == 0);
 }
 
-PassRefPtr<Node> ReplacementFragment::insertFragmentForTestRendering(Node* context)
+PassRefPtr<StyledElement> ReplacementFragment::insertFragmentForTestRendering(Node* context)
 {
-    Node* body = m_document->body();
+    HTMLElement* body = m_document->body();
     if (!body)
         return 0;
 
@@ -266,7 +266,7 @@ PassRefPtr<Node> ReplacementFragment::in
     return holder.release();
 }
 
-void ReplacementFragment::restoreTestRenderingNodesToFragment(Node *holder)
+void ReplacementFragment::restoreTestRenderingNodesToFragment(StyledElement* holder)
 {
     if (!holder)
         return;
@@ -628,7 +628,7 @@ void ReplaceSelectionCommand::handleStyl
         return;
         
     RefPtr<CSSMutableStyleDeclaration> sourceDocumentStyle = static_cast<HTMLElement*>(sourceDocumentStyleSpan)->getInlineStyleDecl()->copy();
-    Node* context = sourceDocumentStyleSpan->parentNode();
+    ContainerNode* context = sourceDocumentStyleSpan->parentNode();
     
     // If Mail wraps the fragment with a Paste as Quotation blockquote, or if you're pasting into a quoted region,
     // styles from blockquoteNode are allowed to override those from the source document, see <rdar://problem/4930986> and <rdar://problem/5089327>.
@@ -710,13 +710,15 @@ void ReplaceSelectionCommand::copyStyleT
     for (Node* childNode = parentNode->firstChild(); childNode; childNode = childNode->nextSibling()) {
         if (childNode->isTextNode() || !isBlock(childNode) || childNode->hasTagName(preTag)) {
             // In this case, put a span tag around the child node.
-            RefPtr<Node> newSpan = parentNode->cloneNode(false);
-            setNodeAttribute(static_cast<Element*>(newSpan.get()), styleAttr, parentStyle->cssText());
+            RefPtr<Node> newNode = parentNode->cloneNode(false);
+            ASSERT(newNode->hasTagName(spanTag));
+            HTMLElement* newSpan = static_cast<HTMLElement*>(newNode.get());
+            setNodeAttribute(newSpan, styleAttr, parentStyle->cssText());
             insertNodeAfter(newSpan, childNode);
             ExceptionCode ec = 0;
             newSpan->appendChild(childNode, ec);
             ASSERT(!ec);
-            childNode = newSpan.get();
+            childNode = newSpan;
         } else if (childNode->isHTMLElement()) {
             // Copy the style attribute and merge them into the child node.  We don't want to override
             // existing styles, so don't clobber on merge.
@@ -1205,7 +1207,7 @@ Node* ReplaceSelectionCommand::insertAsL
 
     while (RefPtr<Node> listItem = listElement->firstChild()) {
         ExceptionCode ec = 0;
-        listElement->removeChild(listItem.get(), ec);
+        toContainerNode(listElement.get())->removeChild(listItem.get(), ec);
         ASSERT(!ec);
         if (isStart || isMiddle)
             insertNodeBefore(listItem, lastNode);
--- a/src/third_party/WebKit/WebCore/editing/SelectionController.cpp
+++ b/src/third_party/WebKit/WebCore/editing/SelectionController.cpp
@@ -1224,11 +1224,10 @@ void SelectionController::selectFrameEle
         return;
 
     // Get to the <iframe> or <frame> (or even <object>) element in the parent frame.
-    Document* doc = m_frame->document();
-    Element* ownerElement = doc->ownerElement();
+    Element* ownerElement = m_frame->document()->ownerElement();
     if (!ownerElement)
         return;
-    Node* ownerElementParent = ownerElement->parentNode();
+    ContainerNode* ownerElementParent = ownerElement->parentNode();
     if (!ownerElementParent)
         return;
         
--- a/src/third_party/WebKit/WebCore/editing/SplitElementCommand.cpp
+++ b/src/third_party/WebKit/WebCore/editing/SplitElementCommand.cpp
@@ -52,7 +52,7 @@ void SplitElementCommand::executeApply()
     
     ExceptionCode ec = 0;
     
-    Node* parent = m_element2->parentNode();
+    ContainerNode* parent = m_element2->parentNode();
     if (!parent || !parent->isContentEditable())
         return;
     parent->insertBefore(m_element1.get(), m_element2.get(), ec);
--- a/src/third_party/WebKit/WebCore/editing/SplitTextNodeCommand.cpp
+++ b/src/third_party/WebKit/WebCore/editing/SplitTextNodeCommand.cpp
@@ -49,7 +49,7 @@ SplitTextNodeCommand::SplitTextNodeComma
 
 void SplitTextNodeCommand::doApply()
 {
-    Node* parent = m_text2->parentNode();
+    ContainerNode* parent = m_text2->parentNode();
     if (!parent || !parent->isContentEditable())
         return;
 
--- a/src/third_party/WebKit/WebCore/editing/TextIterator.cpp
+++ b/src/third_party/WebKit/WebCore/editing/TextIterator.cpp
@@ -149,9 +149,9 @@ unsigned BitStack::size() const
 
 // --------
 
-static inline Node* parentCrossingShadowBoundaries(Node* node)
+static inline ContainerNode* parentCrossingShadowBoundaries(Node* node)
 {
-    if (Node* parent = node->parentNode())
+    if (ContainerNode* parent = node->parentNode())
         return parent;
     return node->shadowParentNode();
 }
--- a/src/third_party/WebKit/WebCore/editing/htmlediting.cpp
+++ b/src/third_party/WebKit/WebCore/editing/htmlediting.cpp
@@ -739,7 +739,7 @@ HTMLElement* enclosingList(Node* node)
         
     Node* root = highestEditableRoot(Position(node, 0));
     
-    for (Node* n = node->parentNode(); n; n = n->parentNode()) {
+    for (ContainerNode* n = node->parentNode(); n; n = n->parentNode()) {
         if (n->hasTagName(ulTag) || n->hasTagName(olTag))
             return static_cast<HTMLElement*>(n);
         if (n == root)
--- a/src/third_party/WebKit/WebCore/editing/markup.cpp
+++ b/src/third_party/WebKit/WebCore/editing/markup.cpp
@@ -985,7 +985,7 @@ String createMarkup(const Range* range,
         
     if (specialCommonAncestor && lastClosed) {
         // Also include all of the ancestors of lastClosed up to this special ancestor.
-        for (Node* ancestor = lastClosed->parentNode(); ancestor; ancestor = ancestor->parentNode()) {
+        for (ContainerNode* ancestor = lastClosed->parentNode(); ancestor; ancestor = ancestor->parentNode()) {
             if (ancestor == fullySelectedRoot && !convertBlocksToInlines) {
                 
                 // Bring the background attribute over, but not as an attribute because a background attribute on a div
@@ -1020,7 +1020,7 @@ String createMarkup(const Range* range,
     }
 
     // Add a wrapper span with the styles that all of the nodes in the markup inherit.
-    Node* parentOfLastClosed = lastClosed ? lastClosed->parentNode() : 0;
+    ContainerNode* parentOfLastClosed = lastClosed ? lastClosed->parentNode() : 0;
     if (parentOfLastClosed && parentOfLastClosed->renderer()) {
         RefPtr<CSSMutableStyleDeclaration> style = ApplyStyleCommand::editingStyleAtPosition(Position(parentOfLastClosed, 0));
 
--- a/src/third_party/WebKit/WebCore/html/HTMLAreaElement.cpp
+++ b/src/third_party/WebKit/WebCore/html/HTMLAreaElement.cpp
@@ -192,7 +192,7 @@ void HTMLAreaElement::dispatchBlurEvent(
     
 void HTMLAreaElement::updateFocusAppearance(bool restorePreviousSelection)
 {
-    Node* parent = parentNode();
+    ContainerNode* parent = parentNode();
     if (!parent || !parent->hasTagName(mapTag))
         return;
     
--- a/src/third_party/WebKit/WebCore/html/HTMLElement.cpp
+++ b/src/third_party/WebKit/WebCore/html/HTMLElement.cpp
@@ -461,7 +461,7 @@ void HTMLElement::setOuterText(const Str
         return;
     }
 
-    Node* parent = parentNode();
+    ContainerNode* parent = parentNode();
     if (!parent) {
         ec = NO_MODIFICATION_ALLOWED_ERR;
         return;
@@ -512,9 +512,8 @@ Node* HTMLElement::insertAdjacent(const
     // Opera also appears to disallow such usage.
 
     if (equalIgnoringCase(where, "beforeBegin")) {
-        if (Node* p = parent())
-            return p->insertBefore(newChild, this, ec) ? newChild : 0;
-        return 0;
+        ContainerNode* parent = this->parent();
+        return (parent && parent->insertBefore(newChild, this, ec)) ? newChild : 0;
     }
 
     if (equalIgnoringCase(where, "afterBegin"))
@@ -524,9 +523,8 @@ Node* HTMLElement::insertAdjacent(const
         return appendChild(newChild, ec) ? newChild : 0;
 
     if (equalIgnoringCase(where, "afterEnd")) {
-        if (Node* p = parent())
-            return p->insertBefore(newChild, nextSibling(), ec) ? newChild : 0;
-        return 0;
+        ContainerNode* parent = this->parent();
+        return (parent && parent->insertBefore(newChild, nextSibling(), ec)) ? newChild : 0;
     }
     
     // IE throws COM Exception E_INVALIDARG; this is the best DOM exception alternative.
@@ -991,9 +989,10 @@ RenderObject* HTMLElement::createRendere
 
 HTMLFormElement* HTMLElement::findFormAncestor() const
 {
-    for (Node* ancestor = parentNode(); ancestor; ancestor = ancestor->parentNode())
+    for (ContainerNode* ancestor = parentNode(); ancestor; ancestor = ancestor->parentNode()) {
         if (ancestor->hasTagName(formTag))
             return static_cast<HTMLFormElement*>(ancestor);
+    }
     return 0;
 }
 
--- a/src/third_party/WebKit/WebCore/html/HTMLEmbedElement.cpp
+++ b/src/third_party/WebKit/WebCore/html/HTMLEmbedElement.cpp
@@ -130,7 +130,7 @@ bool HTMLEmbedElement::rendererIsNeeded(
     if (!frame)
         return false;
 
-    Node* p = parentNode();
+    ContainerNode* p = parentNode();
     if (p && p->hasTagName(objectTag)) {
         ASSERT(p->renderer());
         return false;
--- a/src/third_party/WebKit/WebCore/html/HTMLFormElement.cpp
+++ b/src/third_party/WebKit/WebCore/html/HTMLFormElement.cpp
@@ -116,7 +116,7 @@ bool HTMLFormElement::rendererIsNeeded(R
     if (!isDemoted())
         return HTMLElement::rendererIsNeeded(style);
 
-    Node* node = parentNode();
+    ContainerNode* node = parentNode();
     RenderObject* parentRenderer = node->renderer();
     bool parentIsTableElementPart = (parentRenderer->isTable() && node->hasTagName(tableTag))
         || (parentRenderer->isTableRow() && node->hasTagName(trTag))
--- a/src/third_party/WebKit/WebCore/html/HTMLFrameSetElement.cpp
+++ b/src/third_party/WebKit/WebCore/html/HTMLFrameSetElement.cpp
@@ -173,7 +173,7 @@ void HTMLFrameSetElement::attach()
 {
     // Inherit default settings from parent frameset
     // FIXME: This is not dynamic.
-    for (Node* node = parentNode(); node; node = node->parentNode()) {
+    for (ContainerNode* node = parentNode(); node; node = node->parentNode()) {
         if (node->hasTagName(framesetTag)) {
             HTMLFrameSetElement* frameset = static_cast<HTMLFrameSetElement*>(node);
             if (!frameBorderSet)
--- a/src/third_party/WebKit/WebCore/html/HTMLImageElement.cpp
+++ b/src/third_party/WebKit/WebCore/html/HTMLImageElement.cpp
@@ -234,7 +234,7 @@ void HTMLImageElement::insertedIntoTree(
 {
     if (!m_form) {
         // m_form can be non-null if it was set in constructor.
-        for (Node* ancestor = parentNode(); ancestor; ancestor = ancestor->parentNode()) {
+        for (ContainerNode* ancestor = parentNode(); ancestor; ancestor = ancestor->parentNode()) {
             if (ancestor->hasTagName(formTag)) {
                 m_form = static_cast<HTMLFormElement*>(ancestor);
                 m_form->registerImgElement(this);
--- a/src/third_party/WebKit/WebCore/html/HTMLLegendElement.cpp
+++ b/src/third_party/WebKit/WebCore/html/HTMLLegendElement.cpp
@@ -57,7 +57,7 @@ const AtomicString& HTMLLegendElement::f
 HTMLFormControlElement* HTMLLegendElement::associatedControl()
 {
     // Check if there's a fieldset belonging to this legend.
-    Node* fieldset = parentNode();
+    ContainerNode* fieldset = parentNode();
     while (fieldset && !fieldset->hasTagName(fieldsetTag))
         fieldset = fieldset->parentNode();
     if (!fieldset)
--- a/src/third_party/WebKit/WebCore/html/HTMLOptGroupElement.cpp
+++ b/src/third_party/WebKit/WebCore/html/HTMLOptGroupElement.cpp
@@ -79,7 +79,7 @@ void HTMLOptGroupElement::parseMappedAtt
 
 void HTMLOptGroupElement::recalcSelectOptions()
 {
-    Node* select = parentNode();
+    ContainerNode* select = parentNode();
     while (select && !select->hasTagName(selectTag))
         select = select->parentNode();
     if (select)
@@ -129,7 +129,7 @@ String HTMLOptGroupElement::groupLabelTe
     
 HTMLSelectElement* HTMLOptGroupElement::ownerSelectElement() const
 {
-    Node* select = parentNode();
+    ContainerNode* select = parentNode();
     while (select && !select->hasTagName(selectTag))
         select = select->parentNode();
     
--- a/src/third_party/WebKit/WebCore/html/HTMLOptionElement.cpp
+++ b/src/third_party/WebKit/WebCore/html/HTMLOptionElement.cpp
@@ -198,7 +198,7 @@ void HTMLOptionElement::childrenChanged(
 
 HTMLSelectElement* HTMLOptionElement::ownerSelectElement() const
 {
-    Node* select = parentNode();
+    ContainerNode* select = parentNode();
     while (select && !(select->hasTagName(selectTag) || select->hasTagName(keygenTag)))
         select = select->parentNode();
 
--- a/src/third_party/WebKit/WebCore/html/HTMLTableCellElement.cpp
+++ b/src/third_party/WebKit/WebCore/html/HTMLTableCellElement.cpp
@@ -115,7 +115,7 @@ void HTMLTableCellElement::parseMappedAt
 // used by table cells to share style decls created by the enclosing table.
 void HTMLTableCellElement::additionalAttributeStyleDecls(Vector<CSSMutableStyleDeclaration*>& results)
 {
-    Node* p = parentNode();
+    ContainerNode* p = parentNode();
     while (p && !p->hasTagName(tableTag))
         p = p->parentNode();
     if (!p)
--- a/src/third_party/WebKit/WebCore/html/HTMLTableColElement.cpp
+++ b/src/third_party/WebKit/WebCore/html/HTMLTableColElement.cpp
@@ -102,7 +102,7 @@ void HTMLTableColElement::additionalAttr
 {
     if (!hasLocalName(colgroupTag))
         return;
-    Node* p = parentNode();
+    ContainerNode* p = parentNode();
     while (p && !p->hasTagName(tableTag))
         p = p->parentNode();
     if (!p)
--- a/src/third_party/WebKit/WebCore/html/HTMLTableElement.cpp
+++ b/src/third_party/WebKit/WebCore/html/HTMLTableElement.cpp
@@ -213,7 +213,7 @@ PassRefPtr<HTMLElement> HTMLTableElement
         }
     }
 
-    Node* parent;
+    ContainerNode* parent;
     if (lastRow)
         parent = row ? row->parent() : lastRow->parent();
     else {
--- a/src/third_party/WebKit/WebCore/html/HTMLTableRowElement.cpp
+++ b/src/third_party/WebKit/WebCore/html/HTMLTableRowElement.cpp
@@ -78,7 +78,7 @@ ContainerNode* HTMLTableRowElement::lega
 
 int HTMLTableRowElement::rowIndex() const
 {
-    Node *table = parentNode();
+    ContainerNode* table = parentNode();
     if (!table)
         return -1;
     table = table->parentNode();
--- a/src/third_party/WebKit/WebCore/html/HTMLTableSectionElement.cpp
+++ b/src/third_party/WebKit/WebCore/html/HTMLTableSectionElement.cpp
@@ -72,7 +72,7 @@ ContainerNode* HTMLTableSectionElement::
 // used by table row groups to share style decls created by the enclosing table.
 void HTMLTableSectionElement::additionalAttributeStyleDecls(Vector<CSSMutableStyleDeclaration*>& results)
 {
-    Node* p = parentNode();
+    ContainerNode* p = parentNode();
     while (p && !p->hasTagName(tableTag))
         p = p->parentNode();
     if (!p)
--- a/src/third_party/WebKit/WebCore/inspector/InspectorDOMAgent.cpp
+++ b/src/third_party/WebKit/WebCore/inspector/InspectorDOMAgent.cpp
@@ -466,7 +466,7 @@ void InspectorDOMAgent::removeNode(long
         return;
     }
 
-    Node* parentNode = node->parentNode();
+    ContainerNode* parentNode = node->parentNode();
     if (!parentNode) {
         m_frontend->didRemoveNode(callId, 0);
         return;
@@ -511,7 +511,7 @@ void InspectorDOMAgent::changeTagName(lo
         newElem->appendChild(child, ec);
 
     // Replace the old node with the new node
-    Node* parent = oldNode->parentNode();
+    ContainerNode* parent = oldNode->parentNode();
     parent->insertBefore(newElem, oldNode->nextSibling(), ec);
     parent->removeChild(oldNode, ec);
 
@@ -548,7 +548,7 @@ void InspectorDOMAgent::setOuterHTML(lon
 
     bool childrenRequested = m_childrenRequested.contains(nodeId);
     Node* previousSibling = node->previousSibling();
-    Node* parentNode = node->parentNode();
+    ContainerNode* parentNode = node->parentNode();
 
     HTMLElement* htmlElement = static_cast<HTMLElement*>(node);
     ExceptionCode ec = 0;
@@ -922,8 +922,8 @@ unsigned InspectorDOMAgent::innerChildNo
 
 Node* InspectorDOMAgent::innerParentNode(Node* node)
 {
-    Node* parent = node->parentNode();
-    if (parent && parent->nodeType() == Node::DOCUMENT_NODE)
+    ContainerNode* parent = node->parentNode();
+    if (parent && parent->isDocumentNode())
         return static_cast<Document*>(parent)->ownerElement();
     return parent;
 }
@@ -957,7 +957,7 @@ void InspectorDOMAgent::didInsertDOMNode
     // We could be attaching existing subtree. Forget the bindings.
     unbind(node, &m_documentNodeToIdMap);
 
-    Node* parent = node->parentNode();
+    ContainerNode* parent = node->parentNode();
     long parentId = m_documentNodeToIdMap.get(parent);
     // Return if parent is not mapped yet.
     if (!parentId)
@@ -980,7 +980,7 @@ void InspectorDOMAgent::didRemoveDOMNode
     if (isWhitespace(node))
         return;
 
-    Node* parent = node->parentNode();
+    ContainerNode* parent = node->parentNode();
     long parentId = m_documentNodeToIdMap.get(parent);
     // If parent is not mapped yet -> ignore the event.
     if (!parentId)
--- a/src/third_party/WebKit/WebCore/page/DOMSelection.cpp
+++ b/src/third_party/WebKit/WebCore/page/DOMSelection.cpp
@@ -358,7 +358,7 @@ PassRefPtr<Range> DOMSelection::getRange
     ASSERT(rangeCount() == 1);
 
     if (Node* shadowAncestor = selectionShadowAncestor(m_frame)) {
-        Node* container = shadowAncestor->parentNode();
+        ContainerNode* container = shadowAncestor->parentNode();
         int offset = shadowAncestor->nodeIndex();
         return Range::create(shadowAncestor->document(), container, offset, container, offset);
     }
@@ -446,7 +446,7 @@ bool DOMSelection::containsNode(const No
     if (!n || m_frame->document() != n->document() || selection->isNone())
         return false;
 
-    Node* parentNode = n->parentNode();
+    ContainerNode* parentNode = n->parentNode();
     unsigned nodeIndex = n->nodeIndex();
     RefPtr<Range> selectedRange = selection->selection().toNormalizedRange();
 
--- a/src/third_party/WebKit/WebCore/rendering/RenderSVGGradientStop.cpp
+++ b/src/third_party/WebKit/WebCore/rendering/RenderSVGGradientStop.cpp
@@ -59,7 +59,7 @@ void RenderSVGGradientStop::layout()
 
 SVGGradientElement* RenderSVGGradientStop::gradientElement() const
 {
-    Node* parentNode = node()->parent();
+    ContainerNode* parentNode = node()->parent();
     if (parentNode->hasTagName(linearGradientTag) || parentNode->hasTagName(radialGradientTag))
         return static_cast<SVGGradientElement*>(parentNode);
     return 0;
--- a/src/third_party/WebKit/WebCore/svg/SVGElement.cpp
+++ b/src/third_party/WebKit/WebCore/svg/SVGElement.cpp
@@ -116,7 +116,7 @@ void SVGElement::setXmlbase(const String
 
 SVGSVGElement* SVGElement::ownerSVGElement() const
 {
-    Node* n = isShadowNode() ? const_cast<SVGElement*>(this)->shadowParentNode() : parentNode();
+    ContainerNode* n = isShadowNode() ? const_cast<SVGElement*>(this)->shadowParentNode() : parentNode();
     while (n) {
         if (n->hasTagName(SVGNames::svgTag))
             return static_cast<SVGSVGElement*>(n);
@@ -131,7 +131,7 @@ SVGElement* SVGElement::viewportElement(
 {
     // This function needs shadow tree support - as RenderSVGContainer uses this function
     // to determine the "overflow" property. <use> on <symbol> wouldn't work otherwhise.
-    Node* n = isShadowNode() ? const_cast<SVGElement*>(this)->shadowParentNode() : parentNode();
+    ContainerNode* n = isShadowNode() ? const_cast<SVGElement*>(this)->shadowParentNode() : parentNode();
     while (n) {
         if (n->hasTagName(SVGNames::svgTag) || n->hasTagName(SVGNames::imageTag) || n->hasTagName(SVGNames::symbolTag))
             return static_cast<SVGElement*>(n);
--- a/src/third_party/WebKit/WebCore/svg/SVGFontFaceFormatElement.cpp
+++ b/src/third_party/WebKit/WebCore/svg/SVGFontFaceFormatElement.cpp
@@ -41,7 +41,7 @@ void SVGFontFaceFormatElement::childrenC
     if (!parentNode() || !parentNode()->hasTagName(font_face_uriTag))
         return;
     
-    Node* ancestor = parentNode()->parentNode();
+    ContainerNode* ancestor = parentNode()->parentNode();
     if (!ancestor || !ancestor->hasTagName(font_face_srcTag))
         return;
     
--- a/src/third_party/WebKit/WebCore/svg/SVGFontFaceUriElement.cpp
+++ b/src/third_party/WebKit/WebCore/svg/SVGFontFaceUriElement.cpp
@@ -71,9 +71,9 @@ void SVGFontFaceUriElement::childrenChan
     if (!parentNode() || !parentNode()->hasTagName(font_face_srcTag))
         return;
     
-    Node* grandParent = parentNode()->parentNode();
-    if (grandParent && grandParent->hasTagName(font_faceTag))
-        static_cast<SVGFontFaceElement*>(grandParent)->rebuildFontFace();
+    ContainerNode* grandparent = parentNode()->parentNode();
+    if (grandparent && grandparent->hasTagName(font_faceTag))
+        static_cast<SVGFontFaceElement*>(grandparent)->rebuildFontFace();
 }
 
 void SVGFontFaceUriElement::insertedIntoDocument()
--- a/src/third_party/WebKit/WebCore/svg/SVGGlyphElement.cpp
+++ b/src/third_party/WebKit/WebCore/svg/SVGGlyphElement.cpp
@@ -48,7 +48,7 @@ SVGGlyphElement::~SVGGlyphElement()
 
 void SVGGlyphElement::invalidateGlyphCache()
 {
-    Node* fontNode = parentNode();
+    ContainerNode* fontNode = parentNode();
     if (fontNode && fontNode->hasTagName(SVGNames::fontTag)) {
         if (SVGFontElement* element = static_cast<SVGFontElement*>(fontNode))
             element->invalidateGlyphCache();
--- a/src/third_party/WebKit/WebCore/svg/SVGHKernElement.cpp
+++ b/src/third_party/WebKit/WebCore/svg/SVGHKernElement.cpp
@@ -46,7 +46,7 @@ SVGHKernElement::~SVGHKernElement()
 
 void SVGHKernElement::insertedIntoDocument()
 {
-    Node* fontNode = parentNode();
+    ContainerNode* fontNode = parentNode();
     if (fontNode && fontNode->hasTagName(SVGNames::fontTag)) {
         if (SVGFontElement* element = static_cast<SVGFontElement*>(fontNode))
             element->invalidateGlyphCache();
@@ -55,7 +55,7 @@ void SVGHKernElement::insertedIntoDocume
 
 void SVGHKernElement::removedFromDocument()
 {
-    Node* fontNode = parentNode();
+    ContainerNode* fontNode = parentNode();
     if (fontNode && fontNode->hasTagName(SVGNames::fontTag)) {
         if (SVGFontElement* element = static_cast<SVGFontElement*>(fontNode))
             element->invalidateGlyphCache();
--- a/src/third_party/WebKit/WebCore/svg/SVGLocatable.cpp
+++ b/src/third_party/WebKit/WebCore/svg/SVGLocatable.cpp
@@ -52,7 +52,7 @@ static bool isViewportElement(Node* node
 SVGElement* SVGLocatable::nearestViewportElement(const SVGElement* element)
 {
     ASSERT(element);
-    for (Node* n = element->parentNode(); n && !n->isDocumentNode(); n = n->parentNode()) {
+    for (ContainerNode* n = element->parentNode(); n; n = n->parentNode()) {
         if (isViewportElement(n))
             return static_cast<SVGElement*>(n);
     }
@@ -64,7 +64,7 @@ SVGElement* SVGLocatable::farthestViewpo
 {
     ASSERT(element);
     SVGElement* farthest = 0;
-    for (Node* n = element->parentNode(); n && !n->isDocumentNode(); n = n->parentNode()) {
+    for (ContainerNode* n = element->parentNode(); n; n = n->parentNode()) {
         if (isViewportElement(n))
             farthest = static_cast<SVGElement*>(n);
     }
--- a/src/third_party/WebKit/WebCore/svg/SVGUseElement.cpp
+++ b/src/third_party/WebKit/WebCore/svg/SVGUseElement.cpp
@@ -299,7 +299,7 @@ void SVGUseElement::updateContainerOffse
     SVGElement* shadowRoot = m_targetElementInstance->shadowTreeElement();
     ASSERT(shadowRoot);
 
-    Node* parentNode = shadowRoot->parentNode();
+    ContainerNode* parentNode = shadowRoot->parentNode();
     ASSERT(parentNode);
     ASSERT(parentNode->isSVGElement());
     ASSERT(parentNode->hasTagName(SVGNames::gTag));
@@ -480,7 +480,7 @@ void SVGUseElement::buildShadowAndInstan
 
     // Do not build the shadow/instance tree for <use> elements living in a shadow tree.
     // The will be expanded soon anyway - see expandUseElementsInShadowTree().
-    Node* parent = parentNode();
+    ContainerNode* parent = parentNode();
     while (parent) {
         if (parent->isShadowNode())
             return;
--- a/src/third_party/WebKit/WebCore/svg/SVGVKernElement.cpp
+++ b/src/third_party/WebKit/WebCore/svg/SVGVKernElement.cpp
@@ -44,7 +44,7 @@ SVGVKernElement::~SVGVKernElement()
 
 void SVGVKernElement::insertedIntoDocument()
 {
-    Node* fontNode = parentNode();
+    ContainerNode* fontNode = parentNode();
     if (fontNode && fontNode->hasTagName(SVGNames::fontTag)) {
         if (SVGFontElement* element = static_cast<SVGFontElement*>(fontNode))
             element->invalidateGlyphCache();
@@ -53,7 +53,7 @@ void SVGVKernElement::insertedIntoDocume
 
 void SVGVKernElement::removedFromDocument()
 {
-    Node* fontNode = parentNode();
+    ContainerNode* fontNode = parentNode();
     if (fontNode && fontNode->hasTagName(SVGNames::fontTag)) {
         if (SVGFontElement* element = static_cast<SVGFontElement*>(fontNode))
             element->invalidateGlyphCache();
--- a/src/third_party/WebKit/WebCore/svg/animation/SVGSMILElement.cpp
+++ b/src/third_party/WebKit/WebCore/svg/animation/SVGSMILElement.cpp
@@ -463,7 +463,7 @@ void SVGSMILElement::reschedule()
 SVGElement* SVGSMILElement::targetElement() const
 {
     String href = xlinkHref();
-    Node* target = href.isEmpty() ? parentNode() : document()->getElementById(SVGURIReference::getTarget(href));
+    ContainerNode* target = href.isEmpty() ? parentNode() : document()->getElementById(SVGURIReference::getTarget(href));
     if (target && target->isSVGElement())
         return static_cast<SVGElement*>(target);
     return 0;
--- a/src/third_party/WebKit/WebCore/wml/WMLDoElement.cpp
+++ b/src/third_party/WebKit/WebCore/wml/WMLDoElement.cpp
@@ -115,7 +115,7 @@ void WMLDoElement::insertedIntoDocument(
     if (!hasAttribute(HTMLNames::nameAttr))
         m_name = m_type;
 
-    Node* parent = parentNode();
+    ContainerNode* parent = parentNode();
     if (!parent || !parent->isWMLElement())
         return;
 
@@ -125,7 +125,7 @@ void WMLDoElement::insertedIntoDocument(
 
 void WMLDoElement::removedFromDocument()
 {
-    Node* parent = parentNode();
+    ContainerNode* parent = parentNode();
 
     if (parent  && parent->isWMLElement()) {
         if (WMLEventHandlingElement* eventHandlingElement = toWMLEventHandlingElement(static_cast<WMLElement*>(parent)))
--- a/src/third_party/WebKit/WebCore/wml/WMLNoopElement.cpp
+++ b/src/third_party/WebKit/WebCore/wml/WMLNoopElement.cpp
@@ -44,7 +44,7 @@ void WMLNoopElement::insertedIntoDocumen
 {
     WMLElement::insertedIntoDocument();
 
-    Node* parent = parentNode();
+    ContainerNode* parent = parentNode();
     if (!parent || !parent->isWMLElement())
         return;
 
--- a/src/third_party/WebKit/WebCore/wml/WMLOptGroupElement.cpp
+++ b/src/third_party/WebKit/WebCore/wml/WMLOptGroupElement.cpp
@@ -50,49 +50,9 @@ const AtomicString& WMLOptGroupElement::
     return optgroup;
 }
 
-bool WMLOptGroupElement::insertBefore(PassRefPtr<Node> newChild, Node* refChild, ExceptionCode& ec, bool shouldLazyAttach)
-{
-    bool result = WMLFormControlElement::insertBefore(newChild, refChild, ec, shouldLazyAttach);
-    if (result)
-        recalcSelectOptions();
-    return result;
-}
-
-bool WMLOptGroupElement::replaceChild(PassRefPtr<Node> newChild, Node* oldChild, ExceptionCode& ec, bool shouldLazyAttach)
-{
-    bool result = WMLFormControlElement::replaceChild(newChild, oldChild, ec, shouldLazyAttach);
-    if (result)
-        recalcSelectOptions();
-    return result;
-}
-
-bool WMLOptGroupElement::removeChild(Node* oldChild, ExceptionCode& ec)
-{
-    bool result = WMLFormControlElement::removeChild(oldChild, ec);
-    if (result)
-        recalcSelectOptions();
-    return result;
-}
-
-bool WMLOptGroupElement::appendChild(PassRefPtr<Node> newChild, ExceptionCode& ec, bool shouldLazyAttach)
-{
-    bool result = WMLFormControlElement::appendChild(newChild, ec, shouldLazyAttach);
-    if (result)
-        recalcSelectOptions();
-    return result;
-}
-
-bool WMLOptGroupElement::removeChildren()
-{
-    bool result = WMLFormControlElement::removeChildren();
-    if (result)
-        recalcSelectOptions();
-    return result;
-}
-
 static inline WMLSelectElement* ownerSelectElement(Element* element)
 {
-    Node* select = element->parentNode();
+    ContainerNode* select = element->parentNode();
     while (select && !select->hasTagName(selectTag))
         select = select->parentNode();
 
--- a/src/third_party/WebKit/WebCore/wml/WMLOptGroupElement.h
+++ b/src/third_party/WebKit/WebCore/wml/WMLOptGroupElement.h
@@ -36,12 +36,6 @@ public:
 
     virtual bool rendererIsNeeded(RenderStyle*) { return false; }
 
-    virtual bool insertBefore(PassRefPtr<Node> newChild, Node* refChild, ExceptionCode&, bool shouldLazyAttach = false);
-    virtual bool replaceChild(PassRefPtr<Node> newChild, Node* oldChild, ExceptionCode&, bool shouldLazyAttach = false);
-    virtual bool removeChild(Node* child, ExceptionCode&);
-    virtual bool appendChild(PassRefPtr<Node> newChild, ExceptionCode&, bool shouldLazyAttach = false);
-    virtual bool removeChildren();
-
     virtual void accessKeyAction(bool sendToAnyElement);
     virtual void childrenChanged(bool changedByParser = false, Node* beforeChange = 0, Node* afterChange = 0, int childCountDelta = 0);
     virtual void parseMappedAttribute(Attribute*);
--- a/src/third_party/WebKit/WebCore/wml/WMLOptionElement.cpp
+++ b/src/third_party/WebKit/WebCore/wml/WMLOptionElement.cpp
@@ -51,7 +51,7 @@ const AtomicString& WMLOptionElement::fo
 
 static inline WMLSelectElement* ownerSelectElement(Element* element)
 {
-    Node* select = element->parentNode();
+    ContainerNode* select = element->parentNode();
     while (select && !select->hasTagName(selectTag))
         select = select->parentNode();
 
--- a/src/third_party/WebKit/WebCore/wml/WMLPostfieldElement.cpp
+++ b/src/third_party/WebKit/WebCore/wml/WMLPostfieldElement.cpp
@@ -43,14 +43,14 @@ void WMLPostfieldElement::insertedIntoDo
 {
     WMLElement::insertedIntoDocument();
 
-    Node* parent = parentNode();
+    ContainerNode* parent = parentNode();
     if (parent && parent->hasTagName(goTag))
         static_cast<WMLGoElement*>(parent)->registerPostfieldElement(this);
 }
 
 void WMLPostfieldElement::removedFromDocument()
 {
-    Node* parent = parentNode();
+    ContainerNode* parent = parentNode();
     if (parent && parent->hasTagName(goTag))
         static_cast<WMLGoElement*>(parent)->deregisterPostfieldElement(this);
 
--- a/src/third_party/WebKit/WebCore/wml/WMLSetvarElement.cpp
+++ b/src/third_party/WebKit/WebCore/wml/WMLSetvarElement.cpp
@@ -55,7 +55,7 @@ void WMLSetvarElement::insertedIntoDocum
 {
     WMLElement::insertedIntoDocument();
  
-    Node* parent = parentNode();
+    ContainerNode* parent = parentNode();
     if (!parent || !parent->isWMLElement())
         return;
 
@@ -65,7 +65,7 @@ void WMLSetvarElement::insertedIntoDocum
 
 void WMLSetvarElement::removedFromDocument()
 {
-    Node* parent = parentNode();
+    ContainerNode* parent = parentNode();
     if (parent && parent->isWMLElement()) {
         if (static_cast<WMLElement*>(parent)->isWMLTaskElement())
             static_cast<WMLTaskElement*>(parent)->deregisterVariableSetter(this);
--- a/src/third_party/WebKit/WebCore/wml/WMLTaskElement.cpp
+++ b/src/third_party/WebKit/WebCore/wml/WMLTaskElement.cpp
@@ -47,7 +47,7 @@ void WMLTaskElement::insertedIntoDocumen
 {
     WMLElement::insertedIntoDocument();
 
-    Node* parent = parentNode();
+    ContainerNode* parent = parentNode();
     if (!parent || !parent->isWMLElement())
         return;
 
@@ -61,7 +61,7 @@ void WMLTaskElement::insertedIntoDocumen
 
 void WMLTaskElement::removedFromDocument()
 {
-    Node* parent = parentNode();
+    ContainerNode* parent = parentNode();
     if (parent && parent->isWMLElement()) {
         if (parent->hasTagName(anchorTag))
             static_cast<WMLAnchorElement*>(parent)->deregisterTask(this);
--- a/src/third_party/WebKit/WebCore/wml/WMLTimerElement.cpp
+++ b/src/third_party/WebKit/WebCore/wml/WMLTimerElement.cpp
@@ -58,7 +58,7 @@ void WMLTimerElement::insertedIntoDocume
     if (value().toInt() <= 0)
         return;
 
-    Node* parent = parentNode();
+    ContainerNode* parent = parentNode();
     if (!parent || !parent->isWMLElement())
         return;
 
@@ -70,7 +70,7 @@ void WMLTimerElement::insertedIntoDocume
 
 void WMLTimerElement::removedFromDocument()
 {
-    Node* parent = parentNode();
+    ContainerNode* parent = parentNode();
     if (parent && parent->isWMLElement() && parent->hasTagName(cardTag)) {
         m_card->setIntrinsicEventTimer(0);
         m_card = 0;
--- a/src/third_party/WebKit/WebCore/xml/XPathStep.cpp
+++ b/src/third_party/WebKit/WebCore/xml/XPathStep.cpp
@@ -255,11 +255,11 @@ void Step::nodesInAxis(Node* context, No
             return;
         case ParentAxis:
             if (context->isAttributeNode()) {
-                Node* n = static_cast<Attr*>(context)->ownerElement();
+                Element* n = static_cast<Attr*>(context)->ownerElement();
                 if (nodeMatches(n, ParentAxis, m_nodeTest))
                     nodes.append(n);
             } else {
-                Node* n = context->parentNode();
+                ContainerNode* n = context->parentNode();
                 if (n && nodeMatches(n, ParentAxis, m_nodeTest))
                     nodes.append(n);
             }
