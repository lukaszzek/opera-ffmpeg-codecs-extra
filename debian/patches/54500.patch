--- a/src/third_party/WebKit/WebCore/platform/image-decoders/ImageDecoder.cpp
+++ b/src/third_party/WebKit/WebCore/platform/image-decoders/ImageDecoder.cpp
@@ -126,14 +126,15 @@ void RGBA32Buffer::zeroFill()
     m_hasAlpha = true;
 }
 
-void RGBA32Buffer::copyBitmapData(const RGBA32Buffer& other)
+bool RGBA32Buffer::copyBitmapData(const RGBA32Buffer& other)
 {
     if (this == &other)
-        return;
+        return true;
 
     m_bytes = other.m_bytes;
     m_size = other.m_size;
     setHasAlpha(other.m_hasAlpha);
+    return true;
 }
 
 bool RGBA32Buffer::setSize(int newWidth, int newHeight)
--- a/src/third_party/WebKit/WebCore/platform/image-decoders/ImageDecoder.h
+++ b/src/third_party/WebKit/WebCore/platform/image-decoders/ImageDecoder.h
@@ -84,8 +84,8 @@ namespace WebCore {
         void zeroFill();
 
         // Creates a new copy of the image data in |other|, so the two images
-        // can be modified independently.
-        void copyBitmapData(const RGBA32Buffer& other);
+        // can be modified independently.  Returns whether the copy succeeded.
+        bool copyBitmapData(const RGBA32Buffer& other);
 
         // Copies the pixel data at [(startX, startY), (endX, startY)) to the
         // same X-coordinates on each subsequent row up to but not including
--- a/src/third_party/WebKit/WebCore/platform/image-decoders/gif/GIFImageDecoder.cpp
+++ b/src/third_party/WebKit/WebCore/platform/image-decoders/gif/GIFImageDecoder.cpp
@@ -350,7 +350,8 @@ bool GIFImageDecoder::initFrameBuffer(un
 
         if ((prevMethod == RGBA32Buffer::DisposeNotSpecified) || (prevMethod == RGBA32Buffer::DisposeKeep)) {
             // Preserve the last frame as the starting state for this frame.
-            buffer->copyBitmapData(*prevBuffer);
+            if (!buffer->copyBitmapData(*prevBuffer))
+                return setFailed();
         } else {
             // We want to clear the previous frame to transparent, without
             // affecting pixels in the image outside of the frame.
@@ -363,7 +364,8 @@ bool GIFImageDecoder::initFrameBuffer(un
                     return setFailed();
             } else {
               // Copy the whole previous buffer, then clear just its frame.
-              buffer->copyBitmapData(*prevBuffer);
+              if (!buffer->copyBitmapData(*prevBuffer))
+                  return setFailed();
               for (int y = prevRect.y(); y < prevRect.bottom(); ++y) {
                   for (int x = prevRect.x(); x < prevRect.right(); ++x)
                       buffer->setRGBA(x, y, 0, 0, 0, 0);
--- a/src/third_party/WebKit/WebCore/platform/image-decoders/qt/RGBA32BufferQt.cpp
+++ b/src/third_party/WebKit/WebCore/platform/image-decoders/qt/RGBA32BufferQt.cpp
@@ -75,15 +75,16 @@ void RGBA32Buffer::zeroFill()
     m_pixmap.fill(QColor(0, 0, 0, 0));
 }
 
-void RGBA32Buffer::copyBitmapData(const RGBA32Buffer& other)
+bool RGBA32Buffer::copyBitmapData(const RGBA32Buffer& other)
 {
     if (this == &other)
-        return;
+        return true;
 
     m_image = other.m_image;
     m_pixmap = other.m_pixmap;
     m_size = other.m_size;
     m_hasAlpha = other.m_hasAlpha;
+    return true;
 }
 
 bool RGBA32Buffer::setSize(int newWidth, int newHeight)
--- a/src/third_party/WebKit/WebCore/platform/image-decoders/skia/ImageDecoderSkia.cpp
+++ b/src/third_party/WebKit/WebCore/platform/image-decoders/skia/ImageDecoderSkia.cpp
@@ -67,14 +67,14 @@ void RGBA32Buffer::zeroFill()
     m_bitmap.eraseARGB(0, 0, 0, 0);
 }
 
-void RGBA32Buffer::copyBitmapData(const RGBA32Buffer& other)
+bool RGBA32Buffer::copyBitmapData(const RGBA32Buffer& other)
 {
     if (this == &other)
-        return;
+        return true;
 
     m_bitmap.reset();
     const NativeImageSkia& otherBitmap = other.m_bitmap;
-    otherBitmap.copyTo(&m_bitmap, otherBitmap.config());
+    return otherBitmap.copyTo(&m_bitmap, otherBitmap.config());
 }
 
 bool RGBA32Buffer::setSize(int newWidth, int newHeight)
