--- a/src/third_party/WebKit/WebCore/loader/RedirectScheduler.cpp
+++ b/src/third_party/WebKit/WebCore/loader/RedirectScheduler.cpp
@@ -323,8 +323,8 @@ void RedirectScheduler::scheduleHistoryN
 
     // Invalid history navigations (such as history.forward() during a new load) have the side effect of cancelling any scheduled
     // redirects. We also avoid the possibility of cancelling the current load by avoiding the scheduled redirection altogether.
-    HistoryItem* specifiedEntry = m_frame->page()->backForwardList()->itemAtIndex(steps);
-    if (!specifiedEntry) {
+    BackForwardList* backForwardList = m_frame->page()->backForwardList();
+    if (steps > backForwardList->forwardListCount() || -steps > backForwardList->backListCount()) {
         cancel();
         return;
     }
--- a/src/third_party/WebKit/WebCore/page/Page.cpp
+++ b/src/third_party/WebKit/WebCore/page/Page.cpp
@@ -313,6 +313,9 @@ void Page::goBackOrForward(int distance)
 
 void Page::goToItem(HistoryItem* item, FrameLoadType type)
 {
+    // stopAllLoaders may end up running onload handlers, which could cause further history traversals that may lead to the passed in HistoryItem
+    // being deref()-ed. Make sure we can still use it with HistoryController::goToItem later.
+    RefPtr<HistoryItem> protector(item);
     // Abort any current load unless we're navigating the current document to a new state object
     HistoryItem* currentItem = m_mainFrame->loader()->history()->currentItem();
     if (!item->stateObject() || !currentItem || item->documentSequenceNumber() != currentItem->documentSequenceNumber() || item == currentItem) {
