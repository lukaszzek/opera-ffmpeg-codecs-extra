--- a/src/third_party/WebKit/WebCore/svg/SVGElementInstance.cpp
+++ b/src/third_party/WebKit/WebCore/svg/SVGElementInstance.cpp
@@ -103,7 +103,8 @@ void SVGElementInstance::invalidateAllIn
     const HashSet<SVGElementInstance*>::const_iterator end = set.end();
     for (HashSet<SVGElementInstance*>::const_iterator it = set.begin(); it != end; ++it) {
         ASSERT((*it)->correspondingElement() == element);
-        (*it)->correspondingUseElement()->invalidateShadowTree();
+        if (SVGUseElement* element = (*it)->correspondingUseElement())
+            element->invalidateShadowTree();
     }
 
     // Be sure to rebuild use trees, if needed
--- a/src/third_party/WebKit/WebCore/svg/SVGElementInstance.h
+++ b/src/third_party/WebKit/WebCore/svg/SVGElementInstance.h
@@ -57,6 +57,7 @@ namespace WebCore {
         SVGElement* correspondingElement() const { return m_element.get(); }
         SVGUseElement* correspondingUseElement() const { return m_useElement; }
         SVGElement* shadowTreeElement() const { return m_shadowTreeElement.get(); }
+    void clearUseElement() { m_useElement = 0; }
 
         SVGElementInstance* parentNode() const { return parent(); }
         PassRefPtr<SVGElementInstanceList> childNodes();
--- a/src/third_party/WebKit/WebCore/svg/SVGUseElement.cpp
+++ b/src/third_party/WebKit/WebCore/svg/SVGUseElement.cpp
@@ -131,7 +131,7 @@ void SVGUseElement::insertedIntoDocument
 void SVGUseElement::removedFromDocument()
 {
     SVGStyledTransformableElement::removedFromDocument();
-    m_targetElementInstance = 0;
+    detachInstance();
 }
 
 void SVGUseElement::svgAttributeChanged(const QualifiedName& attrName)
@@ -492,8 +492,7 @@ void SVGUseElement::buildShadowAndInstan
     if (targetElement && targetElement->isSVGElement())
         target = static_cast<SVGElement*>(targetElement);
 
-    if (m_targetElementInstance)
-        m_targetElementInstance = 0;
+    detachInstance();
 
     // Do not allow self-referencing.
     // 'target' may be null, if it's a non SVG namespaced element.
@@ -519,7 +518,7 @@ void SVGUseElement::buildShadowAndInstan
     // SVG specification does not say a word about <use> & cycles. My view on this is: just ignore it!
     // Non-appearing <use> content is easier to debug, then half-appearing content.
     if (foundProblem) {
-        m_targetElementInstance = 0;
+        detachInstance();
         return;
     }
 
@@ -552,7 +551,7 @@ void SVGUseElement::buildShadowAndInstan
     // Do NOT leave an inconsistent instance tree around, instead destruct it.
     if (!m_targetElementInstance->shadowTreeElement()) {
         shadowRoot->removeAllChildren();
-        m_targetElementInstance = 0;
+        detachInstance();
         return;
     }
 
@@ -591,6 +590,14 @@ void SVGUseElement::buildShadowAndInstan
     updateRelativeLengthsInformation();
 }
 
+void SVGUseElement::detachInstance()
+{
+    if (!m_targetElementInstance)
+        return;
+    m_targetElementInstance->clearUseElement();
+    m_targetElementInstance = 0;
+}
+
 RenderObject* SVGUseElement::createRenderer(RenderArena* arena, RenderStyle*)
 {
     return new (arena) RenderSVGShadowTreeRootContainer(this);
@@ -613,7 +620,7 @@ void SVGUseElement::attach()
 void SVGUseElement::detach()
 {
     SVGStyledTransformableElement::detach();
-    m_targetElementInstance = 0;
+    detachInstance();
 }
 
 static bool isDirectReference(Node* n)
--- a/src/third_party/WebKit/WebCore/svg/SVGUseElement.h
+++ b/src/third_party/WebKit/WebCore/svg/SVGUseElement.h
@@ -77,6 +77,7 @@ namespace WebCore {
 
     private:
         virtual bool selfHasRelativeLengths() const;
+    void detachInstance();
 
         DECLARE_ANIMATED_PROPERTY(SVGUseElement, SVGNames::xAttr, SVGLength, X, x)
         DECLARE_ANIMATED_PROPERTY(SVGUseElement, SVGNames::yAttr, SVGLength, Y, y)
