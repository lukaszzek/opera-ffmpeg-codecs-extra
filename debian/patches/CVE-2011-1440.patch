--- a/src/third_party/WebKit/WebCore/rendering/RenderObject.h
+++ b/src/third_party/WebKit/WebCore/rendering/RenderObject.h
@@ -290,7 +290,9 @@ public:
 
     bool isHTMLMarquee() const;
 
+    inline bool isBeforeContent() const;
     inline bool isAfterContent() const;
+    static inline bool isBeforeContent(const RenderObject* obj) { return obj && obj->isBeforeContent(); }
     static inline bool isAfterContent(const RenderObject* obj) { return obj && obj->isAfterContent(); }
 
     bool childrenInline() const { return m_childrenInline; }
@@ -865,6 +867,16 @@ inline bool RenderObject::documentBeingD
     return !document()->renderer();
 }
 
+inline bool RenderObject::isBeforeContent() const
+{
+    if (style()->styleType() != BEFORE)
+        return false;
+    // Text nodes don't have their own styles, so ignore the style on a text node.
+    if (isText() && !isBR())
+        return false;
+    return true;
+}
+
 inline bool RenderObject::isAfterContent() const
 {
     if (style()->styleType() != AFTER)
--- a/src/third_party/WebKit/WebCore/rendering/RenderRuby.cpp
+++ b/src/third_party/WebKit/WebCore/rendering/RenderRuby.cpp
@@ -34,18 +34,53 @@
 #include "RenderRuby.h"
 
 #include "RenderRubyRun.h"
+#include "RenderStyle.h"
+#include <wtf/RefPtr.h>
 
 namespace WebCore {
 
 //=== generic helper functions to avoid excessive code duplication ===
 
+static inline bool isAnonymousRubyInlineBlock(RenderObject* object)
+{
+    ASSERT(!object->parent()->isRuby()
+        || object->isRubyRun()
+        || (object->isInline() && (object->isBeforeContent() || object->isAfterContent()))
+        || (object->isAnonymous() && object->isRenderBlock() && object->style()->display() == INLINE_BLOCK));
+    return object->parent()->isRuby() && object->isRenderBlock() && !object->isRubyRun();
+}
+
+static inline RenderBlock* rubyBeforeBlock(const RenderObject* ruby)
+{
+    RenderObject* child = ruby->firstChild();
+    return child && !child->isRubyRun() && child->isRenderBlock() && child->style()->styleType() == BEFORE ? static_cast<RenderBlock*>(child) : 0;
+}
+
+static inline RenderBlock* rubyAfterBlock(const RenderObject* ruby)
+{
+    RenderObject* child = ruby->lastChild();
+    return child && !child->isRubyRun() && child->isRenderBlock() && child->style()->styleType() == AFTER ? static_cast<RenderBlock*>(child) : 0;
+}
+
+static RenderBlock* createAnonymousRubyInlineBlock(RenderObject* ruby, PseudoId styleType)
+{
+    RefPtr<RenderStyle> newStyle = RenderStyle::create();
+    newStyle->inheritFrom(ruby->style());
+    newStyle->setDisplay(INLINE_BLOCK);
+    newStyle->setStyleType(styleType);
+    
+    RenderBlock* newBlock = new (ruby->renderArena()) RenderBlock(ruby->document() /* anonymous box */);
+    newBlock->setStyle(newStyle.release());
+    return newBlock;
+}
+
 static RenderRubyRun* lastRubyRun(const RenderObject* ruby)
 {
     RenderObject* child = ruby->lastChild();
-    if (child && ruby->isAfterContent(child))
+    if (child && !child->isRubyRun())
         child = child->previousSibling();
-    ASSERT(!child || child->isRubyRun());
-    return static_cast<RenderRubyRun*>(child);
+    ASSERT(!child || child->isRubyRun() || child->isBeforeContent() || child == rubyBeforeBlock(ruby));
+    return child && child->isRubyRun() ? static_cast<RenderRubyRun*>(child) : 0;
 }
 
 static inline RenderRubyRun* findRubyRunParent(RenderObject* child)
@@ -66,18 +101,41 @@ RenderRubyAsInline::~RenderRubyAsInline(
 {
 }
 
-bool RenderRubyAsInline::isChildAllowed(RenderObject* child, RenderStyle*) const
-{
-    return child->isRubyText()
-        || child->isRubyRun()
-        || child->isInline();
-}
-
 void RenderRubyAsInline::addChild(RenderObject* child, RenderObject* beforeChild)
 {
-    // Note: ':after' content is handled implicitely below
+    // Insert :before and :after content before/after the RenderRubyRun(s)
+    if (child->isBeforeContent()) {
+        if (child->isInline()) {
+            // Add generated inline content normally
+            RenderInline::addChild(child, firstChild());
+        } else {
+            // Wrap non-inline content with an anonymous inline-block.
+            RenderBlock* beforeBlock = rubyBeforeBlock(this);
+            if (!beforeBlock) {
+                beforeBlock = createAnonymousRubyInlineBlock(this, BEFORE);
+                RenderInline::addChild(beforeBlock, firstChild());
+            }
+            beforeBlock->addChild(child);
+        }
+        return;
+    }
+    if (child->isAfterContent()) {
+        if (child->isInline()) {
+            // Add generated inline content normally
+            RenderInline::addChild(child);
+        } else {
+            // Wrap non-inline content with an anonymous inline-block.
+            RenderBlock* afterBlock = rubyAfterBlock(this);
+            if (!afterBlock) {
+                afterBlock = createAnonymousRubyInlineBlock(this, AFTER);
+                RenderInline::addChild(afterBlock);
+            }
+            afterBlock->addChild(child);
+        }
+	return;
+    }
 
-    // if child is a ruby run, just add it normally
+    // If the child is a ruby run, just add it normally.
     if (child->isRubyRun()) {
         RenderInline::addChild(child, beforeChild);
         return;
@@ -86,13 +144,14 @@ void RenderRubyAsInline::addChild(Render
     if (beforeChild && !isAfterContent(beforeChild)) {
         // insert child into run
         ASSERT(!beforeChild->isRubyRun());
-        RenderRubyRun* run = findRubyRunParent(beforeChild);
-        ASSERT(run); // beforeChild should always have a run as parent
+        RenderObject* run = beforeChild;
+        while (run && !run->isRubyRun())
+            run = run->parent();
         if (run) {
             run->addChild(child, beforeChild);
             return;
         }
-        ASSERT(false); // beforeChild should always have a run as parent!
+        ASSERT_NOT_REACHED(); // beforeChild should always have a run as parent!
         // Emergency fallback: fall through and just append.
     }
 
@@ -109,15 +168,23 @@ void RenderRubyAsInline::addChild(Render
 
 void RenderRubyAsInline::removeChild(RenderObject* child)
 {
-    // If the child's parent is *this, i.e. a ruby run or ':after' content,
+    // If the child's parent is *this (must be a ruby run or generated content or anonymous block),
     // just use the normal remove method.
     if (child->parent() == this) {
-        ASSERT(child->isRubyRun() || child->isAfterContent());
+        ASSERT(child->isRubyRun() || child->isBeforeContent() || child->isAfterContent() || isAnonymousRubyInlineBlock(child));
         RenderInline::removeChild(child);
         return;
     }
+    // If the child's parent is an anoymous block (must be generated :before/:after content)
+    // just use the block's remove method.
+    if (isAnonymousRubyInlineBlock(child->parent())) {
+        ASSERT(child->isBeforeContent() || child->isAfterContent());
+        child->parent()->removeChild(child);
+        removeChild(child->parent());
+        return;
+    }
 
-    // Find the containing run
+    // Otherwise find the containing run and remove it from there.
     RenderRubyRun* run = findRubyRunParent(child);
     ASSERT(run);
     run->removeChild(child);
@@ -135,18 +202,41 @@ RenderRubyAsBlock::~RenderRubyAsBlock()
 {
 }
 
-bool RenderRubyAsBlock::isChildAllowed(RenderObject* child, RenderStyle*) const
-{
-    return child->isRubyText()
-        || child->isRubyRun()
-        || child->isInline();
-}
-
 void RenderRubyAsBlock::addChild(RenderObject* child, RenderObject* beforeChild)
 {
-    // Note: ':after' content is handled implicitely below
+    // Insert :before and :after content before/after the RenderRubyRun(s)
+    if (child->isBeforeContent()) {
+        if (child->isInline()) {
+            // Add generated inline content normally
+            RenderBlock::addChild(child, firstChild());
+        } else {
+            // Wrap non-inline content with an anonymous inline-block.
+            RenderBlock* beforeBlock = rubyBeforeBlock(this);
+            if (!beforeBlock) {
+                beforeBlock = createAnonymousRubyInlineBlock(this, BEFORE);
+                RenderBlock::addChild(beforeBlock, firstChild());
+            }
+            beforeBlock->addChild(child);
+        }
+        return;
+    }
+    if (child->isAfterContent()) {
+        if (child->isInline()) {
+            // Add generated inline content normally
+            RenderBlock::addChild(child);
+        } else {
+            // Wrap non-inline content with an anonymous inline-block.
+            RenderBlock* afterBlock = rubyAfterBlock(this);
+            if (!afterBlock) {
+                afterBlock = createAnonymousRubyInlineBlock(this, AFTER);
+                RenderBlock::addChild(afterBlock);
+            }
+            afterBlock->addChild(child);
+        }
+        return;
+    }
 
-    // if child is a ruby run, just add it normally
+    // If the child is a ruby run, just add it normally.
     if (child->isRubyRun()) {
         RenderBlock::addChild(child, beforeChild);
         return;
@@ -162,7 +252,7 @@ void RenderRubyAsBlock::addChild(RenderO
             run->addChild(child, beforeChild);
             return;
         }
-        ASSERT(false); // beforeChild should always have a run as parent!
+        ASSERT_NOT_REACHED(); // beforeChild should always have a run as parent!
         // Emergency fallback: fall through and just append.
     }
 
@@ -179,14 +269,23 @@ void RenderRubyAsBlock::addChild(RenderO
 
 void RenderRubyAsBlock::removeChild(RenderObject* child)
 {
-    // If the child's parent is *this, just use the normal remove method.
+    // If the child's parent is *this (must be a ruby run or generated content or anonymous block),
+    // just use the normal remove method.
     if (child->parent() == this) {
-        // This should happen only during destruction of the whole ruby element, though.
+        ASSERT(child->isRubyRun() || child->isBeforeContent() || child->isAfterContent() || isAnonymousRubyInlineBlock(child));
         RenderBlock::removeChild(child);
         return;
     }
+    // If the child's parent is an anoymous block (must be generated :before/:after content)
+    // just use the block's remove method.
+    if (isAnonymousRubyInlineBlock(child->parent())) {
+        ASSERT(child->isBeforeContent() || child->isAfterContent());
+        child->parent()->removeChild(child);
+        removeChild(child->parent());
+        return;
+    }
 
-    // Find the containing run
+    // Otherwise find the containing run and remove it from there.
     RenderRubyRun* run = findRubyRunParent(child);
     ASSERT(run);
     run->removeChild(child);
--- a/src/third_party/WebKit/WebCore/rendering/RenderObjectChildList.cpp
+++ b/src/third_party/WebKit/WebCore/rendering/RenderObjectChildList.cpp
@@ -456,6 +456,12 @@ void RenderObjectChildList::updateBefore
                 // to find the original content properly.
                 generatedContentContainer = RenderObject::createObject(owner->document(), pseudoElementStyle);
                 generatedContentContainer->setStyle(pseudoElementStyle);
+                if (!owner->isChildAllowed(generatedContentContainer, pseudoElementStyle)) {
+                    // The generated content container is not allowed here -> abort.
+                    generatedContentContainer->destroy();
+                    renderer->destroy();
+                    return;
+                }
                 owner->addChild(generatedContentContainer, insertBefore);
             }
             generatedContentContainer->addChild(renderer);
--- a/src/third_party/WebKit/WebCore/rendering/RenderRuby.h
+++ b/src/third_party/WebKit/WebCore/rendering/RenderRuby.h
@@ -49,6 +49,8 @@ namespace WebCore {
 //              1-n inline object(s)
 //
 // Note: <rp> elements are defined as having 'display:none' and thus normally are not assigned a renderer.
+//
+// Generated :before/:after content is shunted into anonymous inline blocks
 
 // <ruby> when used as 'display:inline'
 class RenderRubyAsInline : public RenderInline {
@@ -56,7 +58,6 @@ public:
     RenderRubyAsInline(Node*);
     virtual ~RenderRubyAsInline();
 
-    virtual bool isChildAllowed(RenderObject*, RenderStyle*) const;
     virtual void addChild(RenderObject* child, RenderObject* beforeChild = 0);
     virtual void removeChild(RenderObject* child);
 
@@ -73,7 +74,6 @@ public:
     RenderRubyAsBlock(Node*);
     virtual ~RenderRubyAsBlock();
 
-    virtual bool isChildAllowed(RenderObject*, RenderStyle*) const;
     virtual void addChild(RenderObject* child, RenderObject* beforeChild = 0);
     virtual void removeChild(RenderObject* child);
 
